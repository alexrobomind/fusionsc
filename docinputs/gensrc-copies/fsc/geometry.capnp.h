// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: geometry.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#if CAPNP_VERSION != 9001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "data.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(f2c4d2555710ac22);
CAPNP_DECLARE_SCHEMA(b6edb03f41a01f9b);
CAPNP_DECLARE_SCHEMA(8639820f9894a409);
CAPNP_DECLARE_SCHEMA(d5c4cb265872764b);
CAPNP_DECLARE_SCHEMA(86071d08d4cc141c);
CAPNP_DECLARE_SCHEMA(ea5aaf04149e57eb);
CAPNP_DECLARE_SCHEMA(a3764d675f60b016);
CAPNP_DECLARE_SCHEMA(8f0bb242fc5b513b);
CAPNP_DECLARE_SCHEMA(b234945632305791);
CAPNP_DECLARE_SCHEMA(e74c6788fa76d19c);
CAPNP_DECLARE_SCHEMA(b3d060eaf3540dca);
CAPNP_DECLARE_SCHEMA(be1bbfe49ed0da18);
CAPNP_DECLARE_SCHEMA(ba34a2dae3ba108c);
CAPNP_DECLARE_SCHEMA(b57c1dd30552dc64);
CAPNP_DECLARE_SCHEMA(f2351429f15cb5a6);
CAPNP_DECLARE_SCHEMA(fe4eefc7f0505b5c);
CAPNP_DECLARE_SCHEMA(cfe0321bdfa7c494);
CAPNP_DECLARE_SCHEMA(dcda7e9f816d2ec3);
CAPNP_DECLARE_SCHEMA(f816983b8189e163);
CAPNP_DECLARE_SCHEMA(fedd367d3b4ad897);
CAPNP_DECLARE_SCHEMA(ef17a7c1a8826c90);
CAPNP_DECLARE_SCHEMA(aab63a308ecce1b4);
CAPNP_DECLARE_SCHEMA(da66f5a11744d02c);
CAPNP_DECLARE_SCHEMA(e2f11c977ebecc40);
CAPNP_DECLARE_SCHEMA(a54b2555a0f27c18);
CAPNP_DECLARE_SCHEMA(878eb4eba6b6bf4d);
CAPNP_DECLARE_SCHEMA(9e7f4a1a2fb83dfe);

}  // namespace schemas
}  // namespace capnp

namespace fsc {

struct GeometryResolver {
  GeometryResolver() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct ResolveParams;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(f2c4d2555710ac22)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct GeometryResolver::ResolveParams {
  ResolveParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b6edb03f41a01f9b, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GeometryLib {
  GeometryLib() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct MergeResults;
  struct IndexParams;
  struct IndexResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(8639820f9894a409)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct GeometryLib::MergeResults {
  MergeResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d5c4cb265872764b, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GeometryLib::IndexParams {
  IndexParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(86071d08d4cc141c, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GeometryLib::IndexResults {
  IndexResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ea5aaf04149e57eb, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TagValue {
  TagValue() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    NOT_SET,
    U_INT64,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a3764d675f60b016, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Tag {
  Tag() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8f0bb242fc5b513b, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CartesianGrid {
  CartesianGrid() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b234945632305791, 8, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename T = ::capnp::AnyPointer>
struct Transformed {
  Transformed() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    LEAF,
    SHIFTED,
    TURNED,
  };
  struct Shifted;
  struct Turned;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e74c6788fa76d19c, 2, 3)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct Transformed<T>::Shifted {
  Shifted() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b3d060eaf3540dca, 2, 3)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct Transformed<T>::Turned {
  Turned() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(be1bbfe49ed0da18, 2, 3)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct Mesh {
  Mesh() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    POLY_MESH,
    TRI_MESH,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ba34a2dae3ba108c, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Geometry {
  Geometry() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    COMBINED,
    TRANSFORMED,
    REF,
    MESH,
    COMPONENTS_D_B_MESHES,
    COMPONENTS_D_B_ASSEMBLIES,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b57c1dd30552dc64, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

extern const ::capnp::_::ConstStruct< ::fsc::Geometry> W7X_OP12_DIVERTOR;
extern const ::capnp::_::ConstStruct< ::fsc::Geometry> W7X_OP12_BAFFLES;
extern const ::capnp::_::ConstStruct< ::fsc::Geometry> W7X_OP12_COVERS;
extern const ::capnp::_::ConstStruct< ::fsc::Geometry> W7X_OP12_HEAT_SHIELD;
extern const ::capnp::_::ConstStruct< ::fsc::Geometry> W7X_OP12_PUMP_SLITS;
extern const ::capnp::_::ConstStruct< ::fsc::Geometry> W7X_STEEL_PANELS;
extern const ::capnp::_::ConstStruct< ::fsc::Geometry> W7X_PLASMA_VESSEL;
extern const ::capnp::_::ConstStruct< ::fsc::Geometry> W7X_OP12_PFCS;
struct MergedGeometry {
  MergedGeometry() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Entry;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(da66f5a11744d02c, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MergedGeometry::Entry {
  Entry() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e2f11c977ebecc40, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct IndexedGeometry {
  IndexedGeometry() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct ElementRef;
  struct GridEntry;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a54b2555a0f27c18, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct IndexedGeometry::ElementRef {
  ElementRef() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(878eb4eba6b6bf4d, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct IndexedGeometry::GridEntry {
  GridEntry() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9e7f4a1a2fb83dfe, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

#if !CAPNP_LITE
class GeometryResolver::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef GeometryResolver Calls;
  typedef GeometryResolver Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::fsc::GeometryResolver::ResolveParams,  ::fsc::Geometry> resolveRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class GeometryResolver::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef GeometryResolver Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::fsc::GeometryResolver::ResolveParams ResolveParams;
  typedef ::capnp::CallContext<ResolveParams,  ::fsc::Geometry> ResolveContext;
  virtual ::kj::Promise<void> resolve(ResolveContext context);

  inline  ::fsc::GeometryResolver::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::fsc::GeometryResolver>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class GeometryResolver::ResolveParams::Reader {
public:
  typedef ResolveParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasGeometry() const;
  inline  ::fsc::Geometry::Reader getGeometry() const;

  inline bool getFollowRefs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GeometryResolver::ResolveParams::Builder {
public:
  typedef ResolveParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasGeometry();
  inline  ::fsc::Geometry::Builder getGeometry();
  inline void setGeometry( ::fsc::Geometry::Reader value);
  inline  ::fsc::Geometry::Builder initGeometry();
  inline void adoptGeometry(::capnp::Orphan< ::fsc::Geometry>&& value);
  inline ::capnp::Orphan< ::fsc::Geometry> disownGeometry();

  inline bool getFollowRefs();
  inline void setFollowRefs(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GeometryResolver::ResolveParams::Pipeline {
public:
  typedef ResolveParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::fsc::Geometry::Pipeline getGeometry();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class GeometryLib::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef GeometryLib Calls;
  typedef GeometryLib Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::fsc::Geometry,  ::fsc::GeometryLib::MergeResults> mergeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::fsc::GeometryLib::IndexParams,  ::fsc::GeometryLib::IndexResults> indexRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class GeometryLib::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef GeometryLib Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::fsc::GeometryLib::MergeResults MergeResults;
  typedef ::capnp::CallContext< ::fsc::Geometry, MergeResults> MergeContext;
  virtual ::kj::Promise<void> merge(MergeContext context);
  typedef  ::fsc::GeometryLib::IndexParams IndexParams;
  typedef  ::fsc::GeometryLib::IndexResults IndexResults;
  typedef ::capnp::CallContext<IndexParams, IndexResults> IndexContext;
  virtual ::kj::Promise<void> index(IndexContext context);

  inline  ::fsc::GeometryLib::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::fsc::GeometryLib>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class GeometryLib::MergeResults::Reader {
public:
  typedef MergeResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasRef() const;
#if !CAPNP_LITE
  inline  ::fsc::DataRef< ::fsc::MergedGeometry>::Client getRef() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GeometryLib::MergeResults::Builder {
public:
  typedef MergeResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasRef();
#if !CAPNP_LITE
  inline  ::fsc::DataRef< ::fsc::MergedGeometry>::Client getRef();
  inline void setRef( ::fsc::DataRef< ::fsc::MergedGeometry>::Client&& value);
  inline void setRef( ::fsc::DataRef< ::fsc::MergedGeometry>::Client& value);
  inline void adoptRef(::capnp::Orphan< ::fsc::DataRef< ::fsc::MergedGeometry>>&& value);
  inline ::capnp::Orphan< ::fsc::DataRef< ::fsc::MergedGeometry>> disownRef();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GeometryLib::MergeResults::Pipeline {
public:
  typedef MergeResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::fsc::DataRef< ::fsc::MergedGeometry>::Client getRef();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GeometryLib::IndexParams::Reader {
public:
  typedef IndexParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasGeoRef() const;
#if !CAPNP_LITE
  inline  ::fsc::DataRef< ::fsc::MergedGeometry>::Client getGeoRef() const;
#endif  // !CAPNP_LITE

  inline bool hasGrid() const;
  inline  ::fsc::CartesianGrid::Reader getGrid() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GeometryLib::IndexParams::Builder {
public:
  typedef IndexParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasGeoRef();
#if !CAPNP_LITE
  inline  ::fsc::DataRef< ::fsc::MergedGeometry>::Client getGeoRef();
  inline void setGeoRef( ::fsc::DataRef< ::fsc::MergedGeometry>::Client&& value);
  inline void setGeoRef( ::fsc::DataRef< ::fsc::MergedGeometry>::Client& value);
  inline void adoptGeoRef(::capnp::Orphan< ::fsc::DataRef< ::fsc::MergedGeometry>>&& value);
  inline ::capnp::Orphan< ::fsc::DataRef< ::fsc::MergedGeometry>> disownGeoRef();
#endif  // !CAPNP_LITE

  inline bool hasGrid();
  inline  ::fsc::CartesianGrid::Builder getGrid();
  inline void setGrid( ::fsc::CartesianGrid::Reader value);
  inline  ::fsc::CartesianGrid::Builder initGrid();
  inline void adoptGrid(::capnp::Orphan< ::fsc::CartesianGrid>&& value);
  inline ::capnp::Orphan< ::fsc::CartesianGrid> disownGrid();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GeometryLib::IndexParams::Pipeline {
public:
  typedef IndexParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::fsc::DataRef< ::fsc::MergedGeometry>::Client getGeoRef();
  inline  ::fsc::CartesianGrid::Pipeline getGrid();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GeometryLib::IndexResults::Reader {
public:
  typedef IndexResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasRef() const;
#if !CAPNP_LITE
  inline  ::fsc::DataRef< ::fsc::IndexedGeometry>::Client getRef() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GeometryLib::IndexResults::Builder {
public:
  typedef IndexResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasRef();
#if !CAPNP_LITE
  inline  ::fsc::DataRef< ::fsc::IndexedGeometry>::Client getRef();
  inline void setRef( ::fsc::DataRef< ::fsc::IndexedGeometry>::Client&& value);
  inline void setRef( ::fsc::DataRef< ::fsc::IndexedGeometry>::Client& value);
  inline void adoptRef(::capnp::Orphan< ::fsc::DataRef< ::fsc::IndexedGeometry>>&& value);
  inline ::capnp::Orphan< ::fsc::DataRef< ::fsc::IndexedGeometry>> disownRef();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GeometryLib::IndexResults::Pipeline {
public:
  typedef IndexResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::fsc::DataRef< ::fsc::IndexedGeometry>::Client getRef();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TagValue::Reader {
public:
  typedef TagValue Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isNotSet() const;
  inline  ::capnp::Void getNotSet() const;

  inline bool isUInt64() const;
  inline  ::uint64_t getUInt64() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TagValue::Builder {
public:
  typedef TagValue Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isNotSet();
  inline  ::capnp::Void getNotSet();
  inline void setNotSet( ::capnp::Void value = ::capnp::VOID);

  inline bool isUInt64();
  inline  ::uint64_t getUInt64();
  inline void setUInt64( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TagValue::Pipeline {
public:
  typedef TagValue Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Tag::Reader {
public:
  typedef Tag Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasValue() const;
  inline  ::fsc::TagValue::Reader getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Tag::Builder {
public:
  typedef Tag Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasValue();
  inline  ::fsc::TagValue::Builder getValue();
  inline void setValue( ::fsc::TagValue::Reader value);
  inline  ::fsc::TagValue::Builder initValue();
  inline void adoptValue(::capnp::Orphan< ::fsc::TagValue>&& value);
  inline ::capnp::Orphan< ::fsc::TagValue> disownValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Tag::Pipeline {
public:
  typedef Tag Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::fsc::TagValue::Pipeline getValue();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CartesianGrid::Reader {
public:
  typedef CartesianGrid Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getXMin() const;

  inline double getXMax() const;

  inline double getYMin() const;

  inline double getYMax() const;

  inline double getZMin() const;

  inline double getZMax() const;

  inline  ::uint32_t getNX() const;

  inline  ::uint32_t getNY() const;

  inline  ::uint32_t getNZ() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CartesianGrid::Builder {
public:
  typedef CartesianGrid Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getXMin();
  inline void setXMin(double value);

  inline double getXMax();
  inline void setXMax(double value);

  inline double getYMin();
  inline void setYMin(double value);

  inline double getYMax();
  inline void setYMax(double value);

  inline double getZMin();
  inline void setZMin(double value);

  inline double getZMax();
  inline void setZMax(double value);

  inline  ::uint32_t getNX();
  inline void setNX( ::uint32_t value);

  inline  ::uint32_t getNY();
  inline void setNY( ::uint32_t value);

  inline  ::uint32_t getNZ();
  inline void setNZ( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CartesianGrid::Pipeline {
public:
  typedef CartesianGrid Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class Transformed<T>::Reader {
public:
  typedef Transformed Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename Transformed<T2>::Reader asGeneric() {
    return typename Transformed<T2>::Reader(_reader);
  }

  inline Which which() const;
  inline bool isLeaf() const;
  inline bool hasLeaf() const;
  inline  ::capnp::ReaderFor<T> getLeaf() const;

  inline bool isShifted() const;
  inline typename Shifted::Reader getShifted() const;

  inline bool isTurned() const;
  inline typename Turned::Reader getTurned() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class Transformed<T>::Builder {
public:
  typedef Transformed Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename Transformed<T2>::Builder asGeneric() {
    return typename Transformed<T2>::Builder(_builder);
  }

  inline Which which();
  inline bool isLeaf();
  inline bool hasLeaf();
  inline  ::capnp::BuilderFor<T> getLeaf();
  inline void setLeaf( ::capnp::ReaderFor<T> value);
  inline  ::capnp::BuilderFor<T> initLeaf();
  inline  ::capnp::BuilderFor<T> initLeaf(unsigned int size);
  inline void adoptLeaf(::capnp::Orphan<T>&& value);
  inline ::capnp::Orphan<T> disownLeaf();

  inline bool isShifted();
  inline typename Shifted::Builder getShifted();
  inline typename Shifted::Builder initShifted();

  inline bool isTurned();
  inline typename Turned::Builder getTurned();
  inline typename Turned::Builder initTurned();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class Transformed<T>::Pipeline {
public:
  typedef Transformed Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class Transformed<T>::Shifted::Reader {
public:
  typedef Shifted Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename Transformed<T2>::Shifted::Reader asTransformedGeneric() {
    return typename Transformed<T2>::Shifted::Reader(_reader);
  }

  inline bool hasShift() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getShift() const;

  inline bool hasNode() const;
  inline typename  ::fsc::Transformed<T>::Reader getNode() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class Transformed<T>::Shifted::Builder {
public:
  typedef Shifted Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename Transformed<T2>::Shifted::Builder asTransformedGeneric() {
    return typename Transformed<T2>::Shifted::Builder(_builder);
  }

  inline bool hasShift();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getShift();
  inline void setShift( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setShift(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initShift(unsigned int size);
  inline void adoptShift(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownShift();

  inline bool hasNode();
  inline typename  ::fsc::Transformed<T>::Builder getNode();
  inline void setNode(typename  ::fsc::Transformed<T>::Reader value);
  inline typename  ::fsc::Transformed<T>::Builder initNode();
  inline void adoptNode(::capnp::Orphan< ::fsc::Transformed<T>>&& value);
  inline ::capnp::Orphan< ::fsc::Transformed<T>> disownNode();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class Transformed<T>::Shifted::Pipeline {
public:
  typedef Shifted Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename  ::fsc::Transformed<T>::Pipeline getNode();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class Transformed<T>::Turned::Reader {
public:
  typedef Turned Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename Transformed<T2>::Turned::Reader asTransformedGeneric() {
    return typename Transformed<T2>::Turned::Reader(_reader);
  }

  inline double getAngle() const;

  inline bool hasCenter() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getCenter() const;

  inline bool hasAxis() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getAxis() const;

  inline bool hasNode() const;
  inline typename  ::fsc::Transformed<T>::Reader getNode() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class Transformed<T>::Turned::Builder {
public:
  typedef Turned Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename Transformed<T2>::Turned::Builder asTransformedGeneric() {
    return typename Transformed<T2>::Turned::Builder(_builder);
  }

  inline double getAngle();
  inline void setAngle(double value);

  inline bool hasCenter();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getCenter();
  inline void setCenter( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setCenter(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initCenter(unsigned int size);
  inline void adoptCenter(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownCenter();

  inline bool hasAxis();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getAxis();
  inline void setAxis( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setAxis(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initAxis(unsigned int size);
  inline void adoptAxis(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownAxis();

  inline bool hasNode();
  inline typename  ::fsc::Transformed<T>::Builder getNode();
  inline void setNode(typename  ::fsc::Transformed<T>::Reader value);
  inline typename  ::fsc::Transformed<T>::Builder initNode();
  inline void adoptNode(::capnp::Orphan< ::fsc::Transformed<T>>&& value);
  inline ::capnp::Orphan< ::fsc::Transformed<T>> disownNode();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class Transformed<T>::Turned::Pipeline {
public:
  typedef Turned Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename  ::fsc::Transformed<T>::Pipeline getNode();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Mesh::Reader {
public:
  typedef Mesh Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool hasVertices() const;
  inline  ::fsc::Float64Tensor::Reader getVertices() const;

  inline bool hasIndices() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getIndices() const;

  inline bool isPolyMesh() const;
  inline bool hasPolyMesh() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getPolyMesh() const;

  inline bool isTriMesh() const;
  inline  ::capnp::Void getTriMesh() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Mesh::Builder {
public:
  typedef Mesh Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool hasVertices();
  inline  ::fsc::Float64Tensor::Builder getVertices();
  inline void setVertices( ::fsc::Float64Tensor::Reader value);
  inline  ::fsc::Float64Tensor::Builder initVertices();
  inline void adoptVertices(::capnp::Orphan< ::fsc::Float64Tensor>&& value);
  inline ::capnp::Orphan< ::fsc::Float64Tensor> disownVertices();

  inline bool hasIndices();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getIndices();
  inline void setIndices( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setIndices(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initIndices(unsigned int size);
  inline void adoptIndices(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownIndices();

  inline bool isPolyMesh();
  inline bool hasPolyMesh();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getPolyMesh();
  inline void setPolyMesh( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setPolyMesh(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initPolyMesh(unsigned int size);
  inline void adoptPolyMesh(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownPolyMesh();

  inline bool isTriMesh();
  inline  ::capnp::Void getTriMesh();
  inline void setTriMesh( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Mesh::Pipeline {
public:
  typedef Mesh Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::fsc::Float64Tensor::Pipeline getVertices();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Geometry::Reader {
public:
  typedef Geometry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool hasTags() const;
  inline  ::capnp::List< ::fsc::Tag,  ::capnp::Kind::STRUCT>::Reader getTags() const;

  inline bool isCombined() const;
  inline bool hasCombined() const;
  inline  ::capnp::List< ::fsc::Geometry,  ::capnp::Kind::STRUCT>::Reader getCombined() const;

  inline bool isTransformed() const;
  inline bool hasTransformed() const;
  inline  ::fsc::Transformed< ::fsc::Geometry>::Reader getTransformed() const;

  inline bool isRef() const;
  inline bool hasRef() const;
#if !CAPNP_LITE
  inline  ::fsc::DataRef< ::fsc::Geometry>::Client getRef() const;
#endif  // !CAPNP_LITE

  inline bool isMesh() const;
  inline bool hasMesh() const;
#if !CAPNP_LITE
  inline  ::fsc::DataRef< ::fsc::Mesh>::Client getMesh() const;
#endif  // !CAPNP_LITE

  inline bool isComponentsDBMeshes() const;
  inline bool hasComponentsDBMeshes() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getComponentsDBMeshes() const;

  inline bool isComponentsDBAssemblies() const;
  inline bool hasComponentsDBAssemblies() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getComponentsDBAssemblies() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Geometry::Builder {
public:
  typedef Geometry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool hasTags();
  inline  ::capnp::List< ::fsc::Tag,  ::capnp::Kind::STRUCT>::Builder getTags();
  inline void setTags( ::capnp::List< ::fsc::Tag,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::fsc::Tag,  ::capnp::Kind::STRUCT>::Builder initTags(unsigned int size);
  inline void adoptTags(::capnp::Orphan< ::capnp::List< ::fsc::Tag,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::fsc::Tag,  ::capnp::Kind::STRUCT>> disownTags();

  inline bool isCombined();
  inline bool hasCombined();
  inline  ::capnp::List< ::fsc::Geometry,  ::capnp::Kind::STRUCT>::Builder getCombined();
  inline void setCombined( ::capnp::List< ::fsc::Geometry,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::fsc::Geometry,  ::capnp::Kind::STRUCT>::Builder initCombined(unsigned int size);
  inline void adoptCombined(::capnp::Orphan< ::capnp::List< ::fsc::Geometry,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::fsc::Geometry,  ::capnp::Kind::STRUCT>> disownCombined();

  inline bool isTransformed();
  inline bool hasTransformed();
  inline  ::fsc::Transformed< ::fsc::Geometry>::Builder getTransformed();
  inline void setTransformed( ::fsc::Transformed< ::fsc::Geometry>::Reader value);
  inline  ::fsc::Transformed< ::fsc::Geometry>::Builder initTransformed();
  inline void adoptTransformed(::capnp::Orphan< ::fsc::Transformed< ::fsc::Geometry>>&& value);
  inline ::capnp::Orphan< ::fsc::Transformed< ::fsc::Geometry>> disownTransformed();

  inline bool isRef();
  inline bool hasRef();
#if !CAPNP_LITE
  inline  ::fsc::DataRef< ::fsc::Geometry>::Client getRef();
  inline void setRef( ::fsc::DataRef< ::fsc::Geometry>::Client&& value);
  inline void setRef( ::fsc::DataRef< ::fsc::Geometry>::Client& value);
  inline void adoptRef(::capnp::Orphan< ::fsc::DataRef< ::fsc::Geometry>>&& value);
  inline ::capnp::Orphan< ::fsc::DataRef< ::fsc::Geometry>> disownRef();
#endif  // !CAPNP_LITE

  inline bool isMesh();
  inline bool hasMesh();
#if !CAPNP_LITE
  inline  ::fsc::DataRef< ::fsc::Mesh>::Client getMesh();
  inline void setMesh( ::fsc::DataRef< ::fsc::Mesh>::Client&& value);
  inline void setMesh( ::fsc::DataRef< ::fsc::Mesh>::Client& value);
  inline void adoptMesh(::capnp::Orphan< ::fsc::DataRef< ::fsc::Mesh>>&& value);
  inline ::capnp::Orphan< ::fsc::DataRef< ::fsc::Mesh>> disownMesh();
#endif  // !CAPNP_LITE

  inline bool isComponentsDBMeshes();
  inline bool hasComponentsDBMeshes();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getComponentsDBMeshes();
  inline void setComponentsDBMeshes( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setComponentsDBMeshes(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initComponentsDBMeshes(unsigned int size);
  inline void adoptComponentsDBMeshes(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownComponentsDBMeshes();

  inline bool isComponentsDBAssemblies();
  inline bool hasComponentsDBAssemblies();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getComponentsDBAssemblies();
  inline void setComponentsDBAssemblies( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setComponentsDBAssemblies(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initComponentsDBAssemblies(unsigned int size);
  inline void adoptComponentsDBAssemblies(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownComponentsDBAssemblies();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Geometry::Pipeline {
public:
  typedef Geometry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MergedGeometry::Reader {
public:
  typedef MergedGeometry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTagNames() const;
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader getTagNames() const;

  inline bool hasEntries() const;
  inline  ::capnp::List< ::fsc::MergedGeometry::Entry,  ::capnp::Kind::STRUCT>::Reader getEntries() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MergedGeometry::Builder {
public:
  typedef MergedGeometry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTagNames();
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder getTagNames();
  inline void setTagNames( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value);
  inline void setTagNames(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder initTagNames(unsigned int size);
  inline void adoptTagNames(::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> disownTagNames();

  inline bool hasEntries();
  inline  ::capnp::List< ::fsc::MergedGeometry::Entry,  ::capnp::Kind::STRUCT>::Builder getEntries();
  inline void setEntries( ::capnp::List< ::fsc::MergedGeometry::Entry,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::fsc::MergedGeometry::Entry,  ::capnp::Kind::STRUCT>::Builder initEntries(unsigned int size);
  inline void adoptEntries(::capnp::Orphan< ::capnp::List< ::fsc::MergedGeometry::Entry,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::fsc::MergedGeometry::Entry,  ::capnp::Kind::STRUCT>> disownEntries();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MergedGeometry::Pipeline {
public:
  typedef MergedGeometry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MergedGeometry::Entry::Reader {
public:
  typedef Entry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTags() const;
  inline  ::capnp::List< ::fsc::TagValue,  ::capnp::Kind::STRUCT>::Reader getTags() const;

  inline bool hasMesh() const;
  inline  ::fsc::Mesh::Reader getMesh() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MergedGeometry::Entry::Builder {
public:
  typedef Entry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTags();
  inline  ::capnp::List< ::fsc::TagValue,  ::capnp::Kind::STRUCT>::Builder getTags();
  inline void setTags( ::capnp::List< ::fsc::TagValue,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::fsc::TagValue,  ::capnp::Kind::STRUCT>::Builder initTags(unsigned int size);
  inline void adoptTags(::capnp::Orphan< ::capnp::List< ::fsc::TagValue,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::fsc::TagValue,  ::capnp::Kind::STRUCT>> disownTags();

  inline bool hasMesh();
  inline  ::fsc::Mesh::Builder getMesh();
  inline void setMesh( ::fsc::Mesh::Reader value);
  inline  ::fsc::Mesh::Builder initMesh();
  inline void adoptMesh(::capnp::Orphan< ::fsc::Mesh>&& value);
  inline ::capnp::Orphan< ::fsc::Mesh> disownMesh();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MergedGeometry::Entry::Pipeline {
public:
  typedef Entry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::fsc::Mesh::Pipeline getMesh();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IndexedGeometry::Reader {
public:
  typedef IndexedGeometry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBase() const;
#if !CAPNP_LITE
  inline  ::fsc::DataRef< ::fsc::MergedGeometry>::Client getBase() const;
#endif  // !CAPNP_LITE

  inline bool hasGrid() const;
  inline  ::fsc::CartesianGrid::Reader getGrid() const;

  inline bool hasData() const;
  inline  ::fsc::ShapedList< ::capnp::List< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IndexedGeometry::Builder {
public:
  typedef IndexedGeometry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBase();
#if !CAPNP_LITE
  inline  ::fsc::DataRef< ::fsc::MergedGeometry>::Client getBase();
  inline void setBase( ::fsc::DataRef< ::fsc::MergedGeometry>::Client&& value);
  inline void setBase( ::fsc::DataRef< ::fsc::MergedGeometry>::Client& value);
  inline void adoptBase(::capnp::Orphan< ::fsc::DataRef< ::fsc::MergedGeometry>>&& value);
  inline ::capnp::Orphan< ::fsc::DataRef< ::fsc::MergedGeometry>> disownBase();
#endif  // !CAPNP_LITE

  inline bool hasGrid();
  inline  ::fsc::CartesianGrid::Builder getGrid();
  inline void setGrid( ::fsc::CartesianGrid::Reader value);
  inline  ::fsc::CartesianGrid::Builder initGrid();
  inline void adoptGrid(::capnp::Orphan< ::fsc::CartesianGrid>&& value);
  inline ::capnp::Orphan< ::fsc::CartesianGrid> disownGrid();

  inline bool hasData();
  inline  ::fsc::ShapedList< ::capnp::List< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::Builder getData();
  inline void setData( ::fsc::ShapedList< ::capnp::List< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::Reader value);
  inline  ::fsc::ShapedList< ::capnp::List< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::Builder initData();
  inline void adoptData(::capnp::Orphan< ::fsc::ShapedList< ::capnp::List< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>>&& value);
  inline ::capnp::Orphan< ::fsc::ShapedList< ::capnp::List< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IndexedGeometry::Pipeline {
public:
  typedef IndexedGeometry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::fsc::DataRef< ::fsc::MergedGeometry>::Client getBase();
  inline  ::fsc::CartesianGrid::Pipeline getGrid();
  inline  ::fsc::ShapedList< ::capnp::List< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::Pipeline getData();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IndexedGeometry::ElementRef::Reader {
public:
  typedef ElementRef Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getMeshIndex() const;

  inline  ::uint64_t getElementIndex() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IndexedGeometry::ElementRef::Builder {
public:
  typedef ElementRef Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getMeshIndex();
  inline void setMeshIndex( ::uint64_t value);

  inline  ::uint64_t getElementIndex();
  inline void setElementIndex( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IndexedGeometry::ElementRef::Pipeline {
public:
  typedef ElementRef Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IndexedGeometry::GridEntry::Reader {
public:
  typedef GridEntry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasElements() const;
  inline  ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>::Reader getElements() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IndexedGeometry::GridEntry::Builder {
public:
  typedef GridEntry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasElements();
  inline  ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>::Builder getElements();
  inline void setElements( ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>::Builder initElements(unsigned int size);
  inline void adoptElements(::capnp::Orphan< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>> disownElements();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IndexedGeometry::GridEntry::Pipeline {
public:
  typedef GridEntry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

#if !CAPNP_LITE
inline GeometryResolver::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline GeometryResolver::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline GeometryResolver::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline GeometryResolver::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline GeometryResolver::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::fsc::GeometryResolver::Client& GeometryResolver::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::fsc::GeometryResolver::Client& GeometryResolver::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool GeometryResolver::ResolveParams::Reader::hasGeometry() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GeometryResolver::ResolveParams::Builder::hasGeometry() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::fsc::Geometry::Reader GeometryResolver::ResolveParams::Reader::getGeometry() const {
  return ::capnp::_::PointerHelpers< ::fsc::Geometry>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::fsc::Geometry::Builder GeometryResolver::ResolveParams::Builder::getGeometry() {
  return ::capnp::_::PointerHelpers< ::fsc::Geometry>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fsc::Geometry::Pipeline GeometryResolver::ResolveParams::Pipeline::getGeometry() {
  return  ::fsc::Geometry::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void GeometryResolver::ResolveParams::Builder::setGeometry( ::fsc::Geometry::Reader value) {
  ::capnp::_::PointerHelpers< ::fsc::Geometry>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::fsc::Geometry::Builder GeometryResolver::ResolveParams::Builder::initGeometry() {
  return ::capnp::_::PointerHelpers< ::fsc::Geometry>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void GeometryResolver::ResolveParams::Builder::adoptGeometry(
    ::capnp::Orphan< ::fsc::Geometry>&& value) {
  ::capnp::_::PointerHelpers< ::fsc::Geometry>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fsc::Geometry> GeometryResolver::ResolveParams::Builder::disownGeometry() {
  return ::capnp::_::PointerHelpers< ::fsc::Geometry>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool GeometryResolver::ResolveParams::Reader::getFollowRefs() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool GeometryResolver::ResolveParams::Builder::getFollowRefs() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void GeometryResolver::ResolveParams::Builder::setFollowRefs(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

#if !CAPNP_LITE
inline GeometryLib::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline GeometryLib::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline GeometryLib::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline GeometryLib::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline GeometryLib::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::fsc::GeometryLib::Client& GeometryLib::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::fsc::GeometryLib::Client& GeometryLib::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool GeometryLib::MergeResults::Reader::hasRef() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GeometryLib::MergeResults::Builder::hasRef() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::fsc::DataRef< ::fsc::MergedGeometry>::Client GeometryLib::MergeResults::Reader::getRef() const {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::MergedGeometry>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::fsc::DataRef< ::fsc::MergedGeometry>::Client GeometryLib::MergeResults::Builder::getRef() {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::MergedGeometry>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::fsc::DataRef< ::fsc::MergedGeometry>::Client GeometryLib::MergeResults::Pipeline::getRef() {
  return  ::fsc::DataRef< ::fsc::MergedGeometry>::Client(_typeless.getPointerField(0).asCap());
}
inline void GeometryLib::MergeResults::Builder::setRef( ::fsc::DataRef< ::fsc::MergedGeometry>::Client&& cap) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::MergedGeometry>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void GeometryLib::MergeResults::Builder::setRef( ::fsc::DataRef< ::fsc::MergedGeometry>::Client& cap) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::MergedGeometry>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void GeometryLib::MergeResults::Builder::adoptRef(
    ::capnp::Orphan< ::fsc::DataRef< ::fsc::MergedGeometry>>&& value) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::MergedGeometry>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fsc::DataRef< ::fsc::MergedGeometry>> GeometryLib::MergeResults::Builder::disownRef() {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::MergedGeometry>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool GeometryLib::IndexParams::Reader::hasGeoRef() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GeometryLib::IndexParams::Builder::hasGeoRef() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::fsc::DataRef< ::fsc::MergedGeometry>::Client GeometryLib::IndexParams::Reader::getGeoRef() const {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::MergedGeometry>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::fsc::DataRef< ::fsc::MergedGeometry>::Client GeometryLib::IndexParams::Builder::getGeoRef() {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::MergedGeometry>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::fsc::DataRef< ::fsc::MergedGeometry>::Client GeometryLib::IndexParams::Pipeline::getGeoRef() {
  return  ::fsc::DataRef< ::fsc::MergedGeometry>::Client(_typeless.getPointerField(0).asCap());
}
inline void GeometryLib::IndexParams::Builder::setGeoRef( ::fsc::DataRef< ::fsc::MergedGeometry>::Client&& cap) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::MergedGeometry>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void GeometryLib::IndexParams::Builder::setGeoRef( ::fsc::DataRef< ::fsc::MergedGeometry>::Client& cap) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::MergedGeometry>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void GeometryLib::IndexParams::Builder::adoptGeoRef(
    ::capnp::Orphan< ::fsc::DataRef< ::fsc::MergedGeometry>>&& value) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::MergedGeometry>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fsc::DataRef< ::fsc::MergedGeometry>> GeometryLib::IndexParams::Builder::disownGeoRef() {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::MergedGeometry>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool GeometryLib::IndexParams::Reader::hasGrid() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool GeometryLib::IndexParams::Builder::hasGrid() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::fsc::CartesianGrid::Reader GeometryLib::IndexParams::Reader::getGrid() const {
  return ::capnp::_::PointerHelpers< ::fsc::CartesianGrid>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::fsc::CartesianGrid::Builder GeometryLib::IndexParams::Builder::getGrid() {
  return ::capnp::_::PointerHelpers< ::fsc::CartesianGrid>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fsc::CartesianGrid::Pipeline GeometryLib::IndexParams::Pipeline::getGrid() {
  return  ::fsc::CartesianGrid::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void GeometryLib::IndexParams::Builder::setGrid( ::fsc::CartesianGrid::Reader value) {
  ::capnp::_::PointerHelpers< ::fsc::CartesianGrid>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::fsc::CartesianGrid::Builder GeometryLib::IndexParams::Builder::initGrid() {
  return ::capnp::_::PointerHelpers< ::fsc::CartesianGrid>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void GeometryLib::IndexParams::Builder::adoptGrid(
    ::capnp::Orphan< ::fsc::CartesianGrid>&& value) {
  ::capnp::_::PointerHelpers< ::fsc::CartesianGrid>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fsc::CartesianGrid> GeometryLib::IndexParams::Builder::disownGrid() {
  return ::capnp::_::PointerHelpers< ::fsc::CartesianGrid>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool GeometryLib::IndexResults::Reader::hasRef() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GeometryLib::IndexResults::Builder::hasRef() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::fsc::DataRef< ::fsc::IndexedGeometry>::Client GeometryLib::IndexResults::Reader::getRef() const {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::IndexedGeometry>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::fsc::DataRef< ::fsc::IndexedGeometry>::Client GeometryLib::IndexResults::Builder::getRef() {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::IndexedGeometry>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::fsc::DataRef< ::fsc::IndexedGeometry>::Client GeometryLib::IndexResults::Pipeline::getRef() {
  return  ::fsc::DataRef< ::fsc::IndexedGeometry>::Client(_typeless.getPointerField(0).asCap());
}
inline void GeometryLib::IndexResults::Builder::setRef( ::fsc::DataRef< ::fsc::IndexedGeometry>::Client&& cap) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::IndexedGeometry>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void GeometryLib::IndexResults::Builder::setRef( ::fsc::DataRef< ::fsc::IndexedGeometry>::Client& cap) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::IndexedGeometry>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void GeometryLib::IndexResults::Builder::adoptRef(
    ::capnp::Orphan< ::fsc::DataRef< ::fsc::IndexedGeometry>>&& value) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::IndexedGeometry>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fsc::DataRef< ::fsc::IndexedGeometry>> GeometryLib::IndexResults::Builder::disownRef() {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::IndexedGeometry>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline  ::fsc::TagValue::Which TagValue::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::fsc::TagValue::Which TagValue::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool TagValue::Reader::isNotSet() const {
  return which() == TagValue::NOT_SET;
}
inline bool TagValue::Builder::isNotSet() {
  return which() == TagValue::NOT_SET;
}
inline  ::capnp::Void TagValue::Reader::getNotSet() const {
  KJ_IREQUIRE((which() == TagValue::NOT_SET),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void TagValue::Builder::getNotSet() {
  KJ_IREQUIRE((which() == TagValue::NOT_SET),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TagValue::Builder::setNotSet( ::capnp::Void value) {
  _builder.setDataField<TagValue::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TagValue::NOT_SET);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TagValue::Reader::isUInt64() const {
  return which() == TagValue::U_INT64;
}
inline bool TagValue::Builder::isUInt64() {
  return which() == TagValue::U_INT64;
}
inline  ::uint64_t TagValue::Reader::getUInt64() const {
  KJ_IREQUIRE((which() == TagValue::U_INT64),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t TagValue::Builder::getUInt64() {
  KJ_IREQUIRE((which() == TagValue::U_INT64),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TagValue::Builder::setUInt64( ::uint64_t value) {
  _builder.setDataField<TagValue::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TagValue::U_INT64);
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Tag::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Tag::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Tag::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Tag::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Tag::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Tag::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Tag::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Tag::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Tag::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Tag::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::fsc::TagValue::Reader Tag::Reader::getValue() const {
  return ::capnp::_::PointerHelpers< ::fsc::TagValue>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::fsc::TagValue::Builder Tag::Builder::getValue() {
  return ::capnp::_::PointerHelpers< ::fsc::TagValue>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fsc::TagValue::Pipeline Tag::Pipeline::getValue() {
  return  ::fsc::TagValue::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Tag::Builder::setValue( ::fsc::TagValue::Reader value) {
  ::capnp::_::PointerHelpers< ::fsc::TagValue>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::fsc::TagValue::Builder Tag::Builder::initValue() {
  return ::capnp::_::PointerHelpers< ::fsc::TagValue>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Tag::Builder::adoptValue(
    ::capnp::Orphan< ::fsc::TagValue>&& value) {
  ::capnp::_::PointerHelpers< ::fsc::TagValue>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fsc::TagValue> Tag::Builder::disownValue() {
  return ::capnp::_::PointerHelpers< ::fsc::TagValue>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline double CartesianGrid::Reader::getXMin() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double CartesianGrid::Builder::getXMin() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CartesianGrid::Builder::setXMin(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double CartesianGrid::Reader::getXMax() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double CartesianGrid::Builder::getXMax() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void CartesianGrid::Builder::setXMax(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline double CartesianGrid::Reader::getYMin() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double CartesianGrid::Builder::getYMin() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void CartesianGrid::Builder::setYMin(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline double CartesianGrid::Reader::getYMax() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline double CartesianGrid::Builder::getYMax() {
  return _builder.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void CartesianGrid::Builder::setYMax(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline double CartesianGrid::Reader::getZMin() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline double CartesianGrid::Builder::getZMin() {
  return _builder.getDataField<double>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void CartesianGrid::Builder::setZMin(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline double CartesianGrid::Reader::getZMax() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline double CartesianGrid::Builder::getZMax() {
  return _builder.getDataField<double>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void CartesianGrid::Builder::setZMax(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t CartesianGrid::Reader::getNX() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CartesianGrid::Builder::getNX() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}
inline void CartesianGrid::Builder::setNX( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t CartesianGrid::Reader::getNY() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CartesianGrid::Builder::getNY() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS);
}
inline void CartesianGrid::Builder::setNY( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t CartesianGrid::Reader::getNZ() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t CartesianGrid::Builder::getNZ() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS);
}
inline void CartesianGrid::Builder::setNZ( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS, value);
}

template <typename T>
inline typename  ::fsc::Transformed<T>::Which Transformed<T>::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename T>
inline typename  ::fsc::Transformed<T>::Which Transformed<T>::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename T>
inline bool Transformed<T>::Reader::isLeaf() const {
  return which() == Transformed<T>::LEAF;
}
template <typename T>
inline bool Transformed<T>::Builder::isLeaf() {
  return which() == Transformed<T>::LEAF;
}
template <typename T>
inline bool Transformed<T>::Reader::hasLeaf() const {
  if (which() != Transformed<T>::LEAF) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool Transformed<T>::Builder::hasLeaf() {
  if (which() != Transformed<T>::LEAF) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline  ::capnp::ReaderFor<T> Transformed<T>::Reader::getLeaf() const {
  KJ_IREQUIRE((which() == Transformed<T>::LEAF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<T>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::capnp::BuilderFor<T> Transformed<T>::Builder::getLeaf() {
  KJ_IREQUIRE((which() == Transformed<T>::LEAF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<T>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline void Transformed<T>::Builder::setLeaf( ::capnp::ReaderFor<T> value) {
  _builder.setDataField<Transformed<T>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Transformed<T>::LEAF);
  ::capnp::_::PointerHelpers<T>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename T>
inline  ::capnp::BuilderFor<T> Transformed<T>::Builder::initLeaf() {
  _builder.setDataField<Transformed<T>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Transformed<T>::LEAF);
  return ::capnp::_::PointerHelpers<T>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::capnp::BuilderFor<T> Transformed<T>::Builder::initLeaf(unsigned int size) {
  _builder.setDataField<Transformed<T>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Transformed<T>::LEAF);
  return ::capnp::_::PointerHelpers<T>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename T>
inline void Transformed<T>::Builder::adoptLeaf(
    ::capnp::Orphan<T>&& value) {
  _builder.setDataField<Transformed<T>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Transformed<T>::LEAF);
  ::capnp::_::PointerHelpers<T>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan<T> Transformed<T>::Builder::disownLeaf() {
  KJ_IREQUIRE((which() == Transformed<T>::LEAF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<T>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename T>
inline bool Transformed<T>::Reader::isShifted() const {
  return which() == Transformed<T>::SHIFTED;
}
template <typename T>
inline bool Transformed<T>::Builder::isShifted() {
  return which() == Transformed<T>::SHIFTED;
}
template <typename T>
inline typename Transformed<T>::Shifted::Reader Transformed<T>::Reader::getShifted() const {
  KJ_IREQUIRE((which() == Transformed<T>::SHIFTED),
              "Must check which() before get()ing a union member.");
  return typename Transformed<T>::Shifted::Reader(_reader);
}
template <typename T>
inline typename Transformed<T>::Shifted::Builder Transformed<T>::Builder::getShifted() {
  KJ_IREQUIRE((which() == Transformed<T>::SHIFTED),
              "Must check which() before get()ing a union member.");
  return typename Transformed<T>::Shifted::Builder(_builder);
}
template <typename T>
inline typename Transformed<T>::Shifted::Builder Transformed<T>::Builder::initShifted() {
  _builder.setDataField<Transformed<T>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Transformed<T>::SHIFTED);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).clear();
  return typename Transformed<T>::Shifted::Builder(_builder);
}
template <typename T>
inline bool Transformed<T>::Reader::isTurned() const {
  return which() == Transformed<T>::TURNED;
}
template <typename T>
inline bool Transformed<T>::Builder::isTurned() {
  return which() == Transformed<T>::TURNED;
}
template <typename T>
inline typename Transformed<T>::Turned::Reader Transformed<T>::Reader::getTurned() const {
  KJ_IREQUIRE((which() == Transformed<T>::TURNED),
              "Must check which() before get()ing a union member.");
  return typename Transformed<T>::Turned::Reader(_reader);
}
template <typename T>
inline typename Transformed<T>::Turned::Builder Transformed<T>::Builder::getTurned() {
  KJ_IREQUIRE((which() == Transformed<T>::TURNED),
              "Must check which() before get()ing a union member.");
  return typename Transformed<T>::Turned::Builder(_builder);
}
template <typename T>
inline typename Transformed<T>::Turned::Builder Transformed<T>::Builder::initTurned() {
  _builder.setDataField<Transformed<T>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Transformed<T>::TURNED);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<2>() * ::capnp::POINTERS).clear();
  return typename Transformed<T>::Turned::Builder(_builder);
}
template <typename T>
inline bool Transformed<T>::Shifted::Reader::hasShift() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool Transformed<T>::Shifted::Builder::hasShift() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader Transformed<T>::Shifted::Reader::getShift() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder Transformed<T>::Shifted::Builder::getShift() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline void Transformed<T>::Shifted::Builder::setShift( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename T>
inline void Transformed<T>::Shifted::Builder::setShift(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename T>
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder Transformed<T>::Shifted::Builder::initShift(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename T>
inline void Transformed<T>::Shifted::Builder::adoptShift(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> Transformed<T>::Shifted::Builder::disownShift() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename T>
inline bool Transformed<T>::Shifted::Reader::hasNode() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool Transformed<T>::Shifted::Builder::hasNode() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline typename  ::fsc::Transformed<T>::Reader Transformed<T>::Shifted::Reader::getNode() const {
  return ::capnp::_::PointerHelpers< ::fsc::Transformed<T>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename T>
inline typename  ::fsc::Transformed<T>::Builder Transformed<T>::Shifted::Builder::getNode() {
  return ::capnp::_::PointerHelpers< ::fsc::Transformed<T>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename T>
inline typename  ::fsc::Transformed<T>::Pipeline Transformed<T>::Shifted::Pipeline::getNode() {
  return typename  ::fsc::Transformed<T>::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename T>
inline void Transformed<T>::Shifted::Builder::setNode(typename  ::fsc::Transformed<T>::Reader value) {
  ::capnp::_::PointerHelpers< ::fsc::Transformed<T>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename T>
inline typename  ::fsc::Transformed<T>::Builder Transformed<T>::Shifted::Builder::initNode() {
  return ::capnp::_::PointerHelpers< ::fsc::Transformed<T>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename T>
inline void Transformed<T>::Shifted::Builder::adoptNode(
    ::capnp::Orphan< ::fsc::Transformed<T>>&& value) {
  ::capnp::_::PointerHelpers< ::fsc::Transformed<T>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan< ::fsc::Transformed<T>> Transformed<T>::Shifted::Builder::disownNode() {
  return ::capnp::_::PointerHelpers< ::fsc::Transformed<T>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

// Transformed<T>::Shifted
template <typename T>
constexpr uint16_t Transformed<T>::Shifted::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t Transformed<T>::Shifted::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind Transformed<T>::Shifted::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* Transformed<T>::Shifted::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope Transformed<T>::Shifted::_capnpPrivate::brandScopes[] = {
  { 0xe74c6788fa76d19c, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding Transformed<T>::Shifted::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Dependency Transformed<T>::Shifted::_capnpPrivate::brandDependencies[] = {
  { 16777217,  ::fsc::Transformed<T>::_capnpPrivate::brand() },
};
template <typename T>
const ::capnp::_::RawBrandedSchema Transformed<T>::Shifted::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b3d060eaf3540dca, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

template <typename T>
inline double Transformed<T>::Turned::Reader::getAngle() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

template <typename T>
inline double Transformed<T>::Turned::Builder::getAngle() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
template <typename T>
inline void Transformed<T>::Turned::Builder::setAngle(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

template <typename T>
inline bool Transformed<T>::Turned::Reader::hasCenter() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool Transformed<T>::Turned::Builder::hasCenter() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader Transformed<T>::Turned::Reader::getCenter() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_be1bbfe49ed0da18 + 65);
}
template <typename T>
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder Transformed<T>::Turned::Builder::getCenter() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_be1bbfe49ed0da18 + 65);
}
template <typename T>
inline void Transformed<T>::Turned::Builder::setCenter( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename T>
inline void Transformed<T>::Turned::Builder::setCenter(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename T>
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder Transformed<T>::Turned::Builder::initCenter(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename T>
inline void Transformed<T>::Turned::Builder::adoptCenter(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> Transformed<T>::Turned::Builder::disownCenter() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename T>
inline bool Transformed<T>::Turned::Reader::hasAxis() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool Transformed<T>::Turned::Builder::hasAxis() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader Transformed<T>::Turned::Reader::getAxis() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder Transformed<T>::Turned::Builder::getAxis() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename T>
inline void Transformed<T>::Turned::Builder::setAxis( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename T>
inline void Transformed<T>::Turned::Builder::setAxis(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename T>
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder Transformed<T>::Turned::Builder::initAxis(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename T>
inline void Transformed<T>::Turned::Builder::adoptAxis(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> Transformed<T>::Turned::Builder::disownAxis() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

template <typename T>
inline bool Transformed<T>::Turned::Reader::hasNode() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool Transformed<T>::Turned::Builder::hasNode() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline typename  ::fsc::Transformed<T>::Reader Transformed<T>::Turned::Reader::getNode() const {
  return ::capnp::_::PointerHelpers< ::fsc::Transformed<T>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
template <typename T>
inline typename  ::fsc::Transformed<T>::Builder Transformed<T>::Turned::Builder::getNode() {
  return ::capnp::_::PointerHelpers< ::fsc::Transformed<T>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename T>
inline typename  ::fsc::Transformed<T>::Pipeline Transformed<T>::Turned::Pipeline::getNode() {
  return typename  ::fsc::Transformed<T>::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
template <typename T>
inline void Transformed<T>::Turned::Builder::setNode(typename  ::fsc::Transformed<T>::Reader value) {
  ::capnp::_::PointerHelpers< ::fsc::Transformed<T>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
template <typename T>
inline typename  ::fsc::Transformed<T>::Builder Transformed<T>::Turned::Builder::initNode() {
  return ::capnp::_::PointerHelpers< ::fsc::Transformed<T>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
template <typename T>
inline void Transformed<T>::Turned::Builder::adoptNode(
    ::capnp::Orphan< ::fsc::Transformed<T>>&& value) {
  ::capnp::_::PointerHelpers< ::fsc::Transformed<T>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan< ::fsc::Transformed<T>> Transformed<T>::Turned::Builder::disownNode() {
  return ::capnp::_::PointerHelpers< ::fsc::Transformed<T>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

// Transformed<T>::Turned
template <typename T>
constexpr uint16_t Transformed<T>::Turned::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t Transformed<T>::Turned::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind Transformed<T>::Turned::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* Transformed<T>::Turned::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope Transformed<T>::Turned::_capnpPrivate::brandScopes[] = {
  { 0xe74c6788fa76d19c, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding Transformed<T>::Turned::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Dependency Transformed<T>::Turned::_capnpPrivate::brandDependencies[] = {
  { 16777219,  ::fsc::Transformed<T>::_capnpPrivate::brand() },
};
template <typename T>
const ::capnp::_::RawBrandedSchema Transformed<T>::Turned::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_be1bbfe49ed0da18, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

// Transformed<T>
template <typename T>
constexpr uint16_t Transformed<T>::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t Transformed<T>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind Transformed<T>::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* Transformed<T>::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope Transformed<T>::_capnpPrivate::brandScopes[] = {
  { 0xe74c6788fa76d19c, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding Transformed<T>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Dependency Transformed<T>::_capnpPrivate::brandDependencies[] = {
  { 16777217,  ::fsc::Transformed<T>::Shifted::_capnpPrivate::brand() },
  { 16777218,  ::fsc::Transformed<T>::Turned::_capnpPrivate::brand() },
};
template <typename T>
const ::capnp::_::RawBrandedSchema Transformed<T>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_e74c6788fa76d19c, brandScopes, brandDependencies,
  1, 2, nullptr
};
#endif  // !CAPNP_LITE

inline  ::fsc::Mesh::Which Mesh::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::fsc::Mesh::Which Mesh::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Mesh::Reader::hasVertices() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Mesh::Builder::hasVertices() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::fsc::Float64Tensor::Reader Mesh::Reader::getVertices() const {
  return ::capnp::_::PointerHelpers< ::fsc::Float64Tensor>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::fsc::Float64Tensor::Builder Mesh::Builder::getVertices() {
  return ::capnp::_::PointerHelpers< ::fsc::Float64Tensor>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fsc::Float64Tensor::Pipeline Mesh::Pipeline::getVertices() {
  return  ::fsc::Float64Tensor::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Mesh::Builder::setVertices( ::fsc::Float64Tensor::Reader value) {
  ::capnp::_::PointerHelpers< ::fsc::Float64Tensor>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::fsc::Float64Tensor::Builder Mesh::Builder::initVertices() {
  return ::capnp::_::PointerHelpers< ::fsc::Float64Tensor>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Mesh::Builder::adoptVertices(
    ::capnp::Orphan< ::fsc::Float64Tensor>&& value) {
  ::capnp::_::PointerHelpers< ::fsc::Float64Tensor>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fsc::Float64Tensor> Mesh::Builder::disownVertices() {
  return ::capnp::_::PointerHelpers< ::fsc::Float64Tensor>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Mesh::Reader::hasIndices() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Mesh::Builder::hasIndices() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader Mesh::Reader::getIndices() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Mesh::Builder::getIndices() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Mesh::Builder::setIndices( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void Mesh::Builder::setIndices(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Mesh::Builder::initIndices(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Mesh::Builder::adoptIndices(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> Mesh::Builder::disownIndices() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Mesh::Reader::isPolyMesh() const {
  return which() == Mesh::POLY_MESH;
}
inline bool Mesh::Builder::isPolyMesh() {
  return which() == Mesh::POLY_MESH;
}
inline bool Mesh::Reader::hasPolyMesh() const {
  if (which() != Mesh::POLY_MESH) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Mesh::Builder::hasPolyMesh() {
  if (which() != Mesh::POLY_MESH) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader Mesh::Reader::getPolyMesh() const {
  KJ_IREQUIRE((which() == Mesh::POLY_MESH),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Mesh::Builder::getPolyMesh() {
  KJ_IREQUIRE((which() == Mesh::POLY_MESH),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Mesh::Builder::setPolyMesh( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<Mesh::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Mesh::POLY_MESH);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline void Mesh::Builder::setPolyMesh(::kj::ArrayPtr<const  ::uint32_t> value) {
  _builder.setDataField<Mesh::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Mesh::POLY_MESH);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Mesh::Builder::initPolyMesh(unsigned int size) {
  _builder.setDataField<Mesh::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Mesh::POLY_MESH);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Mesh::Builder::adoptPolyMesh(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<Mesh::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Mesh::POLY_MESH);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> Mesh::Builder::disownPolyMesh() {
  KJ_IREQUIRE((which() == Mesh::POLY_MESH),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Mesh::Reader::isTriMesh() const {
  return which() == Mesh::TRI_MESH;
}
inline bool Mesh::Builder::isTriMesh() {
  return which() == Mesh::TRI_MESH;
}
inline  ::capnp::Void Mesh::Reader::getTriMesh() const {
  KJ_IREQUIRE((which() == Mesh::TRI_MESH),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Mesh::Builder::getTriMesh() {
  KJ_IREQUIRE((which() == Mesh::TRI_MESH),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Mesh::Builder::setTriMesh( ::capnp::Void value) {
  _builder.setDataField<Mesh::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Mesh::TRI_MESH);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::fsc::Geometry::Which Geometry::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::fsc::Geometry::Which Geometry::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Geometry::Reader::hasTags() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Geometry::Builder::hasTags() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::fsc::Tag,  ::capnp::Kind::STRUCT>::Reader Geometry::Reader::getTags() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Tag,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::fsc::Tag,  ::capnp::Kind::STRUCT>::Builder Geometry::Builder::getTags() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Tag,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Geometry::Builder::setTags( ::capnp::List< ::fsc::Tag,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Tag,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::fsc::Tag,  ::capnp::Kind::STRUCT>::Builder Geometry::Builder::initTags(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Tag,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Geometry::Builder::adoptTags(
    ::capnp::Orphan< ::capnp::List< ::fsc::Tag,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Tag,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::fsc::Tag,  ::capnp::Kind::STRUCT>> Geometry::Builder::disownTags() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Tag,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Geometry::Reader::isCombined() const {
  return which() == Geometry::COMBINED;
}
inline bool Geometry::Builder::isCombined() {
  return which() == Geometry::COMBINED;
}
inline bool Geometry::Reader::hasCombined() const {
  if (which() != Geometry::COMBINED) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Geometry::Builder::hasCombined() {
  if (which() != Geometry::COMBINED) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::fsc::Geometry,  ::capnp::Kind::STRUCT>::Reader Geometry::Reader::getCombined() const {
  KJ_IREQUIRE((which() == Geometry::COMBINED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Geometry,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::fsc::Geometry,  ::capnp::Kind::STRUCT>::Builder Geometry::Builder::getCombined() {
  KJ_IREQUIRE((which() == Geometry::COMBINED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Geometry,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Geometry::Builder::setCombined( ::capnp::List< ::fsc::Geometry,  ::capnp::Kind::STRUCT>::Reader value) {
  _builder.setDataField<Geometry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Geometry::COMBINED);
  ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Geometry,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::fsc::Geometry,  ::capnp::Kind::STRUCT>::Builder Geometry::Builder::initCombined(unsigned int size) {
  _builder.setDataField<Geometry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Geometry::COMBINED);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Geometry,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Geometry::Builder::adoptCombined(
    ::capnp::Orphan< ::capnp::List< ::fsc::Geometry,  ::capnp::Kind::STRUCT>>&& value) {
  _builder.setDataField<Geometry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Geometry::COMBINED);
  ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Geometry,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::fsc::Geometry,  ::capnp::Kind::STRUCT>> Geometry::Builder::disownCombined() {
  KJ_IREQUIRE((which() == Geometry::COMBINED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Geometry,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Geometry::Reader::isTransformed() const {
  return which() == Geometry::TRANSFORMED;
}
inline bool Geometry::Builder::isTransformed() {
  return which() == Geometry::TRANSFORMED;
}
inline bool Geometry::Reader::hasTransformed() const {
  if (which() != Geometry::TRANSFORMED) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Geometry::Builder::hasTransformed() {
  if (which() != Geometry::TRANSFORMED) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::fsc::Transformed< ::fsc::Geometry>::Reader Geometry::Reader::getTransformed() const {
  KJ_IREQUIRE((which() == Geometry::TRANSFORMED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::fsc::Transformed< ::fsc::Geometry>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::fsc::Transformed< ::fsc::Geometry>::Builder Geometry::Builder::getTransformed() {
  KJ_IREQUIRE((which() == Geometry::TRANSFORMED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::fsc::Transformed< ::fsc::Geometry>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Geometry::Builder::setTransformed( ::fsc::Transformed< ::fsc::Geometry>::Reader value) {
  _builder.setDataField<Geometry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Geometry::TRANSFORMED);
  ::capnp::_::PointerHelpers< ::fsc::Transformed< ::fsc::Geometry>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::fsc::Transformed< ::fsc::Geometry>::Builder Geometry::Builder::initTransformed() {
  _builder.setDataField<Geometry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Geometry::TRANSFORMED);
  return ::capnp::_::PointerHelpers< ::fsc::Transformed< ::fsc::Geometry>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Geometry::Builder::adoptTransformed(
    ::capnp::Orphan< ::fsc::Transformed< ::fsc::Geometry>>&& value) {
  _builder.setDataField<Geometry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Geometry::TRANSFORMED);
  ::capnp::_::PointerHelpers< ::fsc::Transformed< ::fsc::Geometry>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fsc::Transformed< ::fsc::Geometry>> Geometry::Builder::disownTransformed() {
  KJ_IREQUIRE((which() == Geometry::TRANSFORMED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::fsc::Transformed< ::fsc::Geometry>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Geometry::Reader::isRef() const {
  return which() == Geometry::REF;
}
inline bool Geometry::Builder::isRef() {
  return which() == Geometry::REF;
}
inline bool Geometry::Reader::hasRef() const {
  if (which() != Geometry::REF) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Geometry::Builder::hasRef() {
  if (which() != Geometry::REF) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::fsc::DataRef< ::fsc::Geometry>::Client Geometry::Reader::getRef() const {
  KJ_IREQUIRE((which() == Geometry::REF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::Geometry>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::fsc::DataRef< ::fsc::Geometry>::Client Geometry::Builder::getRef() {
  KJ_IREQUIRE((which() == Geometry::REF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::Geometry>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Geometry::Builder::setRef( ::fsc::DataRef< ::fsc::Geometry>::Client&& cap) {
  _builder.setDataField<Geometry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Geometry::REF);
  ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::Geometry>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Geometry::Builder::setRef( ::fsc::DataRef< ::fsc::Geometry>::Client& cap) {
  _builder.setDataField<Geometry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Geometry::REF);
  ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::Geometry>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), cap);
}
inline void Geometry::Builder::adoptRef(
    ::capnp::Orphan< ::fsc::DataRef< ::fsc::Geometry>>&& value) {
  _builder.setDataField<Geometry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Geometry::REF);
  ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::Geometry>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fsc::DataRef< ::fsc::Geometry>> Geometry::Builder::disownRef() {
  KJ_IREQUIRE((which() == Geometry::REF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::Geometry>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Geometry::Reader::isMesh() const {
  return which() == Geometry::MESH;
}
inline bool Geometry::Builder::isMesh() {
  return which() == Geometry::MESH;
}
inline bool Geometry::Reader::hasMesh() const {
  if (which() != Geometry::MESH) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Geometry::Builder::hasMesh() {
  if (which() != Geometry::MESH) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::fsc::DataRef< ::fsc::Mesh>::Client Geometry::Reader::getMesh() const {
  KJ_IREQUIRE((which() == Geometry::MESH),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::Mesh>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::fsc::DataRef< ::fsc::Mesh>::Client Geometry::Builder::getMesh() {
  KJ_IREQUIRE((which() == Geometry::MESH),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::Mesh>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Geometry::Builder::setMesh( ::fsc::DataRef< ::fsc::Mesh>::Client&& cap) {
  _builder.setDataField<Geometry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Geometry::MESH);
  ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::Mesh>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Geometry::Builder::setMesh( ::fsc::DataRef< ::fsc::Mesh>::Client& cap) {
  _builder.setDataField<Geometry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Geometry::MESH);
  ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::Mesh>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), cap);
}
inline void Geometry::Builder::adoptMesh(
    ::capnp::Orphan< ::fsc::DataRef< ::fsc::Mesh>>&& value) {
  _builder.setDataField<Geometry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Geometry::MESH);
  ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::Mesh>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fsc::DataRef< ::fsc::Mesh>> Geometry::Builder::disownMesh() {
  KJ_IREQUIRE((which() == Geometry::MESH),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::Mesh>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Geometry::Reader::isComponentsDBMeshes() const {
  return which() == Geometry::COMPONENTS_D_B_MESHES;
}
inline bool Geometry::Builder::isComponentsDBMeshes() {
  return which() == Geometry::COMPONENTS_D_B_MESHES;
}
inline bool Geometry::Reader::hasComponentsDBMeshes() const {
  if (which() != Geometry::COMPONENTS_D_B_MESHES) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Geometry::Builder::hasComponentsDBMeshes() {
  if (which() != Geometry::COMPONENTS_D_B_MESHES) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader Geometry::Reader::getComponentsDBMeshes() const {
  KJ_IREQUIRE((which() == Geometry::COMPONENTS_D_B_MESHES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder Geometry::Builder::getComponentsDBMeshes() {
  KJ_IREQUIRE((which() == Geometry::COMPONENTS_D_B_MESHES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Geometry::Builder::setComponentsDBMeshes( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<Geometry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Geometry::COMPONENTS_D_B_MESHES);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void Geometry::Builder::setComponentsDBMeshes(::kj::ArrayPtr<const  ::uint64_t> value) {
  _builder.setDataField<Geometry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Geometry::COMPONENTS_D_B_MESHES);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder Geometry::Builder::initComponentsDBMeshes(unsigned int size) {
  _builder.setDataField<Geometry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Geometry::COMPONENTS_D_B_MESHES);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Geometry::Builder::adoptComponentsDBMeshes(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<Geometry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Geometry::COMPONENTS_D_B_MESHES);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> Geometry::Builder::disownComponentsDBMeshes() {
  KJ_IREQUIRE((which() == Geometry::COMPONENTS_D_B_MESHES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Geometry::Reader::isComponentsDBAssemblies() const {
  return which() == Geometry::COMPONENTS_D_B_ASSEMBLIES;
}
inline bool Geometry::Builder::isComponentsDBAssemblies() {
  return which() == Geometry::COMPONENTS_D_B_ASSEMBLIES;
}
inline bool Geometry::Reader::hasComponentsDBAssemblies() const {
  if (which() != Geometry::COMPONENTS_D_B_ASSEMBLIES) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Geometry::Builder::hasComponentsDBAssemblies() {
  if (which() != Geometry::COMPONENTS_D_B_ASSEMBLIES) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader Geometry::Reader::getComponentsDBAssemblies() const {
  KJ_IREQUIRE((which() == Geometry::COMPONENTS_D_B_ASSEMBLIES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder Geometry::Builder::getComponentsDBAssemblies() {
  KJ_IREQUIRE((which() == Geometry::COMPONENTS_D_B_ASSEMBLIES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Geometry::Builder::setComponentsDBAssemblies( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<Geometry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Geometry::COMPONENTS_D_B_ASSEMBLIES);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void Geometry::Builder::setComponentsDBAssemblies(::kj::ArrayPtr<const  ::uint64_t> value) {
  _builder.setDataField<Geometry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Geometry::COMPONENTS_D_B_ASSEMBLIES);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder Geometry::Builder::initComponentsDBAssemblies(unsigned int size) {
  _builder.setDataField<Geometry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Geometry::COMPONENTS_D_B_ASSEMBLIES);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Geometry::Builder::adoptComponentsDBAssemblies(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<Geometry::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Geometry::COMPONENTS_D_B_ASSEMBLIES);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> Geometry::Builder::disownComponentsDBAssemblies() {
  KJ_IREQUIRE((which() == Geometry::COMPONENTS_D_B_ASSEMBLIES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool MergedGeometry::Reader::hasTagNames() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool MergedGeometry::Builder::hasTagNames() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader MergedGeometry::Reader::getTagNames() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder MergedGeometry::Builder::getTagNames() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MergedGeometry::Builder::setTagNames( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void MergedGeometry::Builder::setTagNames(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder MergedGeometry::Builder::initTagNames(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void MergedGeometry::Builder::adoptTagNames(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> MergedGeometry::Builder::disownTagNames() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool MergedGeometry::Reader::hasEntries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool MergedGeometry::Builder::hasEntries() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::fsc::MergedGeometry::Entry,  ::capnp::Kind::STRUCT>::Reader MergedGeometry::Reader::getEntries() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::MergedGeometry::Entry,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::fsc::MergedGeometry::Entry,  ::capnp::Kind::STRUCT>::Builder MergedGeometry::Builder::getEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::MergedGeometry::Entry,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void MergedGeometry::Builder::setEntries( ::capnp::List< ::fsc::MergedGeometry::Entry,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::MergedGeometry::Entry,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::fsc::MergedGeometry::Entry,  ::capnp::Kind::STRUCT>::Builder MergedGeometry::Builder::initEntries(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::MergedGeometry::Entry,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void MergedGeometry::Builder::adoptEntries(
    ::capnp::Orphan< ::capnp::List< ::fsc::MergedGeometry::Entry,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::MergedGeometry::Entry,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::fsc::MergedGeometry::Entry,  ::capnp::Kind::STRUCT>> MergedGeometry::Builder::disownEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::MergedGeometry::Entry,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool MergedGeometry::Entry::Reader::hasTags() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool MergedGeometry::Entry::Builder::hasTags() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::fsc::TagValue,  ::capnp::Kind::STRUCT>::Reader MergedGeometry::Entry::Reader::getTags() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::TagValue,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::fsc::TagValue,  ::capnp::Kind::STRUCT>::Builder MergedGeometry::Entry::Builder::getTags() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::TagValue,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MergedGeometry::Entry::Builder::setTags( ::capnp::List< ::fsc::TagValue,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::TagValue,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::fsc::TagValue,  ::capnp::Kind::STRUCT>::Builder MergedGeometry::Entry::Builder::initTags(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::TagValue,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void MergedGeometry::Entry::Builder::adoptTags(
    ::capnp::Orphan< ::capnp::List< ::fsc::TagValue,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::TagValue,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::fsc::TagValue,  ::capnp::Kind::STRUCT>> MergedGeometry::Entry::Builder::disownTags() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::TagValue,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool MergedGeometry::Entry::Reader::hasMesh() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool MergedGeometry::Entry::Builder::hasMesh() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::fsc::Mesh::Reader MergedGeometry::Entry::Reader::getMesh() const {
  return ::capnp::_::PointerHelpers< ::fsc::Mesh>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::fsc::Mesh::Builder MergedGeometry::Entry::Builder::getMesh() {
  return ::capnp::_::PointerHelpers< ::fsc::Mesh>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fsc::Mesh::Pipeline MergedGeometry::Entry::Pipeline::getMesh() {
  return  ::fsc::Mesh::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void MergedGeometry::Entry::Builder::setMesh( ::fsc::Mesh::Reader value) {
  ::capnp::_::PointerHelpers< ::fsc::Mesh>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::fsc::Mesh::Builder MergedGeometry::Entry::Builder::initMesh() {
  return ::capnp::_::PointerHelpers< ::fsc::Mesh>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void MergedGeometry::Entry::Builder::adoptMesh(
    ::capnp::Orphan< ::fsc::Mesh>&& value) {
  ::capnp::_::PointerHelpers< ::fsc::Mesh>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fsc::Mesh> MergedGeometry::Entry::Builder::disownMesh() {
  return ::capnp::_::PointerHelpers< ::fsc::Mesh>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool IndexedGeometry::Reader::hasBase() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool IndexedGeometry::Builder::hasBase() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::fsc::DataRef< ::fsc::MergedGeometry>::Client IndexedGeometry::Reader::getBase() const {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::MergedGeometry>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::fsc::DataRef< ::fsc::MergedGeometry>::Client IndexedGeometry::Builder::getBase() {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::MergedGeometry>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::fsc::DataRef< ::fsc::MergedGeometry>::Client IndexedGeometry::Pipeline::getBase() {
  return  ::fsc::DataRef< ::fsc::MergedGeometry>::Client(_typeless.getPointerField(0).asCap());
}
inline void IndexedGeometry::Builder::setBase( ::fsc::DataRef< ::fsc::MergedGeometry>::Client&& cap) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::MergedGeometry>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void IndexedGeometry::Builder::setBase( ::fsc::DataRef< ::fsc::MergedGeometry>::Client& cap) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::MergedGeometry>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void IndexedGeometry::Builder::adoptBase(
    ::capnp::Orphan< ::fsc::DataRef< ::fsc::MergedGeometry>>&& value) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::MergedGeometry>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fsc::DataRef< ::fsc::MergedGeometry>> IndexedGeometry::Builder::disownBase() {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef< ::fsc::MergedGeometry>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool IndexedGeometry::Reader::hasGrid() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool IndexedGeometry::Builder::hasGrid() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::fsc::CartesianGrid::Reader IndexedGeometry::Reader::getGrid() const {
  return ::capnp::_::PointerHelpers< ::fsc::CartesianGrid>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::fsc::CartesianGrid::Builder IndexedGeometry::Builder::getGrid() {
  return ::capnp::_::PointerHelpers< ::fsc::CartesianGrid>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fsc::CartesianGrid::Pipeline IndexedGeometry::Pipeline::getGrid() {
  return  ::fsc::CartesianGrid::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void IndexedGeometry::Builder::setGrid( ::fsc::CartesianGrid::Reader value) {
  ::capnp::_::PointerHelpers< ::fsc::CartesianGrid>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::fsc::CartesianGrid::Builder IndexedGeometry::Builder::initGrid() {
  return ::capnp::_::PointerHelpers< ::fsc::CartesianGrid>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void IndexedGeometry::Builder::adoptGrid(
    ::capnp::Orphan< ::fsc::CartesianGrid>&& value) {
  ::capnp::_::PointerHelpers< ::fsc::CartesianGrid>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fsc::CartesianGrid> IndexedGeometry::Builder::disownGrid() {
  return ::capnp::_::PointerHelpers< ::fsc::CartesianGrid>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool IndexedGeometry::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool IndexedGeometry::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::fsc::ShapedList< ::capnp::List< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::Reader IndexedGeometry::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::fsc::ShapedList< ::capnp::List< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::fsc::ShapedList< ::capnp::List< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::Builder IndexedGeometry::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::fsc::ShapedList< ::capnp::List< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fsc::ShapedList< ::capnp::List< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::Pipeline IndexedGeometry::Pipeline::getData() {
  return  ::fsc::ShapedList< ::capnp::List< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void IndexedGeometry::Builder::setData( ::fsc::ShapedList< ::capnp::List< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::Reader value) {
  ::capnp::_::PointerHelpers< ::fsc::ShapedList< ::capnp::List< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::fsc::ShapedList< ::capnp::List< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::Builder IndexedGeometry::Builder::initData() {
  return ::capnp::_::PointerHelpers< ::fsc::ShapedList< ::capnp::List< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void IndexedGeometry::Builder::adoptData(
    ::capnp::Orphan< ::fsc::ShapedList< ::capnp::List< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>>&& value) {
  ::capnp::_::PointerHelpers< ::fsc::ShapedList< ::capnp::List< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fsc::ShapedList< ::capnp::List< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>> IndexedGeometry::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::fsc::ShapedList< ::capnp::List< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::uint64_t IndexedGeometry::ElementRef::Reader::getMeshIndex() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t IndexedGeometry::ElementRef::Builder::getMeshIndex() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IndexedGeometry::ElementRef::Builder::setMeshIndex( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t IndexedGeometry::ElementRef::Reader::getElementIndex() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t IndexedGeometry::ElementRef::Builder::getElementIndex() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void IndexedGeometry::ElementRef::Builder::setElementIndex( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool IndexedGeometry::GridEntry::Reader::hasElements() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool IndexedGeometry::GridEntry::Builder::hasElements() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>::Reader IndexedGeometry::GridEntry::Reader::getElements() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>::Builder IndexedGeometry::GridEntry::Builder::getElements() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void IndexedGeometry::GridEntry::Builder::setElements( ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>::Builder IndexedGeometry::GridEntry::Builder::initElements(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void IndexedGeometry::GridEntry::Builder::adoptElements(
    ::capnp::Orphan< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>> IndexedGeometry::GridEntry::Builder::disownElements() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::IndexedGeometry::ElementRef,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

}  // namespace

CAPNP_END_HEADER

