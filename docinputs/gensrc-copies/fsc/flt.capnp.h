// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: flt.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 9001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "data.capnp.h"
#include "magnetics.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(9b963df0f312c515);
enum class FLTStopReason_9b963df0f312c515: uint16_t {
  UNKNOWN,
  STEP_LIMIT,
  DISTANCE_LIMIT,
  TURN_LIMIT,
  EVENT_BUFFER_FULL,
  OUT_OF_GRID,
};
CAPNP_DECLARE_ENUM(FLTStopReason, 9b963df0f312c515);
CAPNP_DECLARE_SCHEMA(b9b57c9030fc534a);
CAPNP_DECLARE_SCHEMA(e55570bc21f97ea4);
CAPNP_DECLARE_SCHEMA(8064f06b6606a057);
CAPNP_DECLARE_SCHEMA(df6d302ca8c9b3a7);
CAPNP_DECLARE_SCHEMA(b32abc2982ff82bd);
CAPNP_DECLARE_SCHEMA(fa8e7c439b6a9377);

}  // namespace schemas
}  // namespace capnp

namespace fsc {

typedef ::capnp::schemas::FLTStopReason_9b963df0f312c515 FLTStopReason;

struct FLTKernelState {
  FLTKernelState() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b9b57c9030fc534a, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FLTKernelEvent {
  FLTKernelEvent() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    OUT_OF_GRID,
    PHI_PLANE_INTERSECTION,
    NEW_TURN,
  };
  struct PhiPlaneIntersection;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e55570bc21f97ea4, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FLTKernelEvent::PhiPlaneIntersection {
  PhiPlaneIntersection() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8064f06b6606a057, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FLTKernelData {
  FLTKernelData() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Entry;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(df6d302ca8c9b3a7, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FLTKernelData::Entry {
  Entry() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b32abc2982ff82bd, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FLTKernelRequest {
  FLTKernelRequest() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fa8e7c439b6a9377, 2, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class FLTKernelState::Reader {
public:
  typedef FLTKernelState Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPosition() const;
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader getPosition() const;

  inline  ::uint32_t getNumSteps() const;

  inline float getDistance() const;

  inline  ::uint32_t getTurnCount() const;

  inline float getPhi0() const;

  inline  ::uint32_t getEventCount() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FLTKernelState::Builder {
public:
  typedef FLTKernelState Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPosition();
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder getPosition();
  inline void setPosition( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setPosition(::kj::ArrayPtr<const float> value);
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder initPosition(unsigned int size);
  inline void adoptPosition(::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> disownPosition();

  inline  ::uint32_t getNumSteps();
  inline void setNumSteps( ::uint32_t value);

  inline float getDistance();
  inline void setDistance(float value);

  inline  ::uint32_t getTurnCount();
  inline void setTurnCount( ::uint32_t value);

  inline float getPhi0();
  inline void setPhi0(float value);

  inline  ::uint32_t getEventCount();
  inline void setEventCount( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FLTKernelState::Pipeline {
public:
  typedef FLTKernelState Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FLTKernelEvent::Reader {
public:
  typedef FLTKernelEvent Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool hasLocation() const;
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader getLocation() const;

  inline  ::uint32_t getStep() const;

  inline float getDistance() const;

  inline bool isOutOfGrid() const;
  inline  ::capnp::Void getOutOfGrid() const;

  inline bool isPhiPlaneIntersection() const;
  inline typename PhiPlaneIntersection::Reader getPhiPlaneIntersection() const;

  inline bool isNewTurn() const;
  inline  ::uint32_t getNewTurn() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FLTKernelEvent::Builder {
public:
  typedef FLTKernelEvent Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool hasLocation();
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder getLocation();
  inline void setLocation( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setLocation(::kj::ArrayPtr<const float> value);
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder initLocation(unsigned int size);
  inline void adoptLocation(::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> disownLocation();

  inline  ::uint32_t getStep();
  inline void setStep( ::uint32_t value);

  inline float getDistance();
  inline void setDistance(float value);

  inline bool isOutOfGrid();
  inline  ::capnp::Void getOutOfGrid();
  inline void setOutOfGrid( ::capnp::Void value = ::capnp::VOID);

  inline bool isPhiPlaneIntersection();
  inline typename PhiPlaneIntersection::Builder getPhiPlaneIntersection();
  inline typename PhiPlaneIntersection::Builder initPhiPlaneIntersection();

  inline bool isNewTurn();
  inline  ::uint32_t getNewTurn();
  inline void setNewTurn( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FLTKernelEvent::Pipeline {
public:
  typedef FLTKernelEvent Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FLTKernelEvent::PhiPlaneIntersection::Reader {
public:
  typedef PhiPlaneIntersection Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getPlaneNo() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FLTKernelEvent::PhiPlaneIntersection::Builder {
public:
  typedef PhiPlaneIntersection Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getPlaneNo();
  inline void setPlaneNo( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FLTKernelEvent::PhiPlaneIntersection::Pipeline {
public:
  typedef PhiPlaneIntersection Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FLTKernelData::Reader {
public:
  typedef FLTKernelData Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::fsc::FLTKernelData::Entry,  ::capnp::Kind::STRUCT>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FLTKernelData::Builder {
public:
  typedef FLTKernelData Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::fsc::FLTKernelData::Entry,  ::capnp::Kind::STRUCT>::Builder getData();
  inline void setData( ::capnp::List< ::fsc::FLTKernelData::Entry,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::fsc::FLTKernelData::Entry,  ::capnp::Kind::STRUCT>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::fsc::FLTKernelData::Entry,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::fsc::FLTKernelData::Entry,  ::capnp::Kind::STRUCT>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FLTKernelData::Pipeline {
public:
  typedef FLTKernelData Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FLTKernelData::Entry::Reader {
public:
  typedef Entry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::fsc::FLTStopReason getStopReason() const;

  inline bool hasState() const;
  inline  ::fsc::FLTKernelState::Reader getState() const;

  inline bool hasEvents() const;
  inline  ::capnp::List< ::fsc::FLTKernelEvent,  ::capnp::Kind::STRUCT>::Reader getEvents() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FLTKernelData::Entry::Builder {
public:
  typedef Entry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::fsc::FLTStopReason getStopReason();
  inline void setStopReason( ::fsc::FLTStopReason value);

  inline bool hasState();
  inline  ::fsc::FLTKernelState::Builder getState();
  inline void setState( ::fsc::FLTKernelState::Reader value);
  inline  ::fsc::FLTKernelState::Builder initState();
  inline void adoptState(::capnp::Orphan< ::fsc::FLTKernelState>&& value);
  inline ::capnp::Orphan< ::fsc::FLTKernelState> disownState();

  inline bool hasEvents();
  inline  ::capnp::List< ::fsc::FLTKernelEvent,  ::capnp::Kind::STRUCT>::Builder getEvents();
  inline void setEvents( ::capnp::List< ::fsc::FLTKernelEvent,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::fsc::FLTKernelEvent,  ::capnp::Kind::STRUCT>::Builder initEvents(unsigned int size);
  inline void adoptEvents(::capnp::Orphan< ::capnp::List< ::fsc::FLTKernelEvent,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::fsc::FLTKernelEvent,  ::capnp::Kind::STRUCT>> disownEvents();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FLTKernelData::Entry::Pipeline {
public:
  typedef Entry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::fsc::FLTKernelState::Pipeline getState();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FLTKernelRequest::Reader {
public:
  typedef FLTKernelRequest Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPhiPlanes() const;
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader getPhiPlanes() const;

  inline  ::uint32_t getTurnLimit() const;

  inline float getDistanceLimit() const;

  inline  ::uint32_t getStepLimit() const;

  inline float getStepSize() const;

  inline bool hasGrid() const;
  inline  ::fsc::ToroidalGrid::Reader getGrid() const;

  inline bool hasFieldData() const;
  inline  ::fsc::Float64Tensor::Reader getFieldData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FLTKernelRequest::Builder {
public:
  typedef FLTKernelRequest Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPhiPlanes();
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder getPhiPlanes();
  inline void setPhiPlanes( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setPhiPlanes(::kj::ArrayPtr<const float> value);
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder initPhiPlanes(unsigned int size);
  inline void adoptPhiPlanes(::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> disownPhiPlanes();

  inline  ::uint32_t getTurnLimit();
  inline void setTurnLimit( ::uint32_t value);

  inline float getDistanceLimit();
  inline void setDistanceLimit(float value);

  inline  ::uint32_t getStepLimit();
  inline void setStepLimit( ::uint32_t value);

  inline float getStepSize();
  inline void setStepSize(float value);

  inline bool hasGrid();
  inline  ::fsc::ToroidalGrid::Builder getGrid();
  inline void setGrid( ::fsc::ToroidalGrid::Reader value);
  inline  ::fsc::ToroidalGrid::Builder initGrid();
  inline void adoptGrid(::capnp::Orphan< ::fsc::ToroidalGrid>&& value);
  inline ::capnp::Orphan< ::fsc::ToroidalGrid> disownGrid();

  inline bool hasFieldData();
  inline  ::fsc::Float64Tensor::Builder getFieldData();
  inline void setFieldData( ::fsc::Float64Tensor::Reader value);
  inline  ::fsc::Float64Tensor::Builder initFieldData();
  inline void adoptFieldData(::capnp::Orphan< ::fsc::Float64Tensor>&& value);
  inline ::capnp::Orphan< ::fsc::Float64Tensor> disownFieldData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FLTKernelRequest::Pipeline {
public:
  typedef FLTKernelRequest Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::fsc::ToroidalGrid::Pipeline getGrid();
  inline  ::fsc::Float64Tensor::Pipeline getFieldData();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool FLTKernelState::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FLTKernelState::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader FLTKernelState::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder FLTKernelState::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FLTKernelState::Builder::setPosition( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void FLTKernelState::Builder::setPosition(::kj::ArrayPtr<const float> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder FLTKernelState::Builder::initPosition(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void FLTKernelState::Builder::adoptPosition(
    ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> FLTKernelState::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t FLTKernelState::Reader::getNumSteps() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t FLTKernelState::Builder::getNumSteps() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FLTKernelState::Builder::setNumSteps( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float FLTKernelState::Reader::getDistance() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float FLTKernelState::Builder::getDistance() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void FLTKernelState::Builder::setDistance(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t FLTKernelState::Reader::getTurnCount() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t FLTKernelState::Builder::getTurnCount() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void FLTKernelState::Builder::setTurnCount( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float FLTKernelState::Reader::getPhi0() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float FLTKernelState::Builder::getPhi0() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void FLTKernelState::Builder::setPhi0(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t FLTKernelState::Reader::getEventCount() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t FLTKernelState::Builder::getEventCount() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void FLTKernelState::Builder::setEventCount( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::fsc::FLTKernelEvent::Which FLTKernelEvent::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline  ::fsc::FLTKernelEvent::Which FLTKernelEvent::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline bool FLTKernelEvent::Reader::hasLocation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FLTKernelEvent::Builder::hasLocation() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader FLTKernelEvent::Reader::getLocation() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder FLTKernelEvent::Builder::getLocation() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FLTKernelEvent::Builder::setLocation( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void FLTKernelEvent::Builder::setLocation(::kj::ArrayPtr<const float> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder FLTKernelEvent::Builder::initLocation(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void FLTKernelEvent::Builder::adoptLocation(
    ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> FLTKernelEvent::Builder::disownLocation() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t FLTKernelEvent::Reader::getStep() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t FLTKernelEvent::Builder::getStep() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FLTKernelEvent::Builder::setStep( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float FLTKernelEvent::Reader::getDistance() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float FLTKernelEvent::Builder::getDistance() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void FLTKernelEvent::Builder::setDistance(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool FLTKernelEvent::Reader::isOutOfGrid() const {
  return which() == FLTKernelEvent::OUT_OF_GRID;
}
inline bool FLTKernelEvent::Builder::isOutOfGrid() {
  return which() == FLTKernelEvent::OUT_OF_GRID;
}
inline  ::capnp::Void FLTKernelEvent::Reader::getOutOfGrid() const {
  KJ_IREQUIRE((which() == FLTKernelEvent::OUT_OF_GRID),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FLTKernelEvent::Builder::getOutOfGrid() {
  KJ_IREQUIRE((which() == FLTKernelEvent::OUT_OF_GRID),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FLTKernelEvent::Builder::setOutOfGrid( ::capnp::Void value) {
  _builder.setDataField<FLTKernelEvent::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, FLTKernelEvent::OUT_OF_GRID);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FLTKernelEvent::Reader::isPhiPlaneIntersection() const {
  return which() == FLTKernelEvent::PHI_PLANE_INTERSECTION;
}
inline bool FLTKernelEvent::Builder::isPhiPlaneIntersection() {
  return which() == FLTKernelEvent::PHI_PLANE_INTERSECTION;
}
inline typename FLTKernelEvent::PhiPlaneIntersection::Reader FLTKernelEvent::Reader::getPhiPlaneIntersection() const {
  KJ_IREQUIRE((which() == FLTKernelEvent::PHI_PLANE_INTERSECTION),
              "Must check which() before get()ing a union member.");
  return typename FLTKernelEvent::PhiPlaneIntersection::Reader(_reader);
}
inline typename FLTKernelEvent::PhiPlaneIntersection::Builder FLTKernelEvent::Builder::getPhiPlaneIntersection() {
  KJ_IREQUIRE((which() == FLTKernelEvent::PHI_PLANE_INTERSECTION),
              "Must check which() before get()ing a union member.");
  return typename FLTKernelEvent::PhiPlaneIntersection::Builder(_builder);
}
inline typename FLTKernelEvent::PhiPlaneIntersection::Builder FLTKernelEvent::Builder::initPhiPlaneIntersection() {
  _builder.setDataField<FLTKernelEvent::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, FLTKernelEvent::PHI_PLANE_INTERSECTION);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<3>() * ::capnp::ELEMENTS, 0);
  return typename FLTKernelEvent::PhiPlaneIntersection::Builder(_builder);
}
inline bool FLTKernelEvent::Reader::isNewTurn() const {
  return which() == FLTKernelEvent::NEW_TURN;
}
inline bool FLTKernelEvent::Builder::isNewTurn() {
  return which() == FLTKernelEvent::NEW_TURN;
}
inline  ::uint32_t FLTKernelEvent::Reader::getNewTurn() const {
  KJ_IREQUIRE((which() == FLTKernelEvent::NEW_TURN),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t FLTKernelEvent::Builder::getNewTurn() {
  KJ_IREQUIRE((which() == FLTKernelEvent::NEW_TURN),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void FLTKernelEvent::Builder::setNewTurn( ::uint32_t value) {
  _builder.setDataField<FLTKernelEvent::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, FLTKernelEvent::NEW_TURN);
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t FLTKernelEvent::PhiPlaneIntersection::Reader::getPlaneNo() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t FLTKernelEvent::PhiPlaneIntersection::Builder::getPlaneNo() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void FLTKernelEvent::PhiPlaneIntersection::Builder::setPlaneNo( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool FLTKernelData::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FLTKernelData::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::fsc::FLTKernelData::Entry,  ::capnp::Kind::STRUCT>::Reader FLTKernelData::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::FLTKernelData::Entry,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::fsc::FLTKernelData::Entry,  ::capnp::Kind::STRUCT>::Builder FLTKernelData::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::FLTKernelData::Entry,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FLTKernelData::Builder::setData( ::capnp::List< ::fsc::FLTKernelData::Entry,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::FLTKernelData::Entry,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::fsc::FLTKernelData::Entry,  ::capnp::Kind::STRUCT>::Builder FLTKernelData::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::FLTKernelData::Entry,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void FLTKernelData::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::fsc::FLTKernelData::Entry,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::FLTKernelData::Entry,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::fsc::FLTKernelData::Entry,  ::capnp::Kind::STRUCT>> FLTKernelData::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::FLTKernelData::Entry,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::fsc::FLTStopReason FLTKernelData::Entry::Reader::getStopReason() const {
  return _reader.getDataField< ::fsc::FLTStopReason>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::fsc::FLTStopReason FLTKernelData::Entry::Builder::getStopReason() {
  return _builder.getDataField< ::fsc::FLTStopReason>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FLTKernelData::Entry::Builder::setStopReason( ::fsc::FLTStopReason value) {
  _builder.setDataField< ::fsc::FLTStopReason>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FLTKernelData::Entry::Reader::hasState() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FLTKernelData::Entry::Builder::hasState() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::fsc::FLTKernelState::Reader FLTKernelData::Entry::Reader::getState() const {
  return ::capnp::_::PointerHelpers< ::fsc::FLTKernelState>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::fsc::FLTKernelState::Builder FLTKernelData::Entry::Builder::getState() {
  return ::capnp::_::PointerHelpers< ::fsc::FLTKernelState>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fsc::FLTKernelState::Pipeline FLTKernelData::Entry::Pipeline::getState() {
  return  ::fsc::FLTKernelState::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void FLTKernelData::Entry::Builder::setState( ::fsc::FLTKernelState::Reader value) {
  ::capnp::_::PointerHelpers< ::fsc::FLTKernelState>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::fsc::FLTKernelState::Builder FLTKernelData::Entry::Builder::initState() {
  return ::capnp::_::PointerHelpers< ::fsc::FLTKernelState>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FLTKernelData::Entry::Builder::adoptState(
    ::capnp::Orphan< ::fsc::FLTKernelState>&& value) {
  ::capnp::_::PointerHelpers< ::fsc::FLTKernelState>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fsc::FLTKernelState> FLTKernelData::Entry::Builder::disownState() {
  return ::capnp::_::PointerHelpers< ::fsc::FLTKernelState>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool FLTKernelData::Entry::Reader::hasEvents() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool FLTKernelData::Entry::Builder::hasEvents() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::fsc::FLTKernelEvent,  ::capnp::Kind::STRUCT>::Reader FLTKernelData::Entry::Reader::getEvents() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::FLTKernelEvent,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::fsc::FLTKernelEvent,  ::capnp::Kind::STRUCT>::Builder FLTKernelData::Entry::Builder::getEvents() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::FLTKernelEvent,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void FLTKernelData::Entry::Builder::setEvents( ::capnp::List< ::fsc::FLTKernelEvent,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::FLTKernelEvent,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::fsc::FLTKernelEvent,  ::capnp::Kind::STRUCT>::Builder FLTKernelData::Entry::Builder::initEvents(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::FLTKernelEvent,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void FLTKernelData::Entry::Builder::adoptEvents(
    ::capnp::Orphan< ::capnp::List< ::fsc::FLTKernelEvent,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::FLTKernelEvent,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::fsc::FLTKernelEvent,  ::capnp::Kind::STRUCT>> FLTKernelData::Entry::Builder::disownEvents() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::FLTKernelEvent,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool FLTKernelRequest::Reader::hasPhiPlanes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FLTKernelRequest::Builder::hasPhiPlanes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader FLTKernelRequest::Reader::getPhiPlanes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder FLTKernelRequest::Builder::getPhiPlanes() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FLTKernelRequest::Builder::setPhiPlanes( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void FLTKernelRequest::Builder::setPhiPlanes(::kj::ArrayPtr<const float> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder FLTKernelRequest::Builder::initPhiPlanes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void FLTKernelRequest::Builder::adoptPhiPlanes(
    ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> FLTKernelRequest::Builder::disownPhiPlanes() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t FLTKernelRequest::Reader::getTurnLimit() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t FLTKernelRequest::Builder::getTurnLimit() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FLTKernelRequest::Builder::setTurnLimit( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float FLTKernelRequest::Reader::getDistanceLimit() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float FLTKernelRequest::Builder::getDistanceLimit() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void FLTKernelRequest::Builder::setDistanceLimit(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t FLTKernelRequest::Reader::getStepLimit() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t FLTKernelRequest::Builder::getStepLimit() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void FLTKernelRequest::Builder::setStepLimit( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float FLTKernelRequest::Reader::getStepSize() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float FLTKernelRequest::Builder::getStepSize() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void FLTKernelRequest::Builder::setStepSize(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool FLTKernelRequest::Reader::hasGrid() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool FLTKernelRequest::Builder::hasGrid() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::fsc::ToroidalGrid::Reader FLTKernelRequest::Reader::getGrid() const {
  return ::capnp::_::PointerHelpers< ::fsc::ToroidalGrid>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::fsc::ToroidalGrid::Builder FLTKernelRequest::Builder::getGrid() {
  return ::capnp::_::PointerHelpers< ::fsc::ToroidalGrid>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fsc::ToroidalGrid::Pipeline FLTKernelRequest::Pipeline::getGrid() {
  return  ::fsc::ToroidalGrid::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void FLTKernelRequest::Builder::setGrid( ::fsc::ToroidalGrid::Reader value) {
  ::capnp::_::PointerHelpers< ::fsc::ToroidalGrid>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::fsc::ToroidalGrid::Builder FLTKernelRequest::Builder::initGrid() {
  return ::capnp::_::PointerHelpers< ::fsc::ToroidalGrid>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void FLTKernelRequest::Builder::adoptGrid(
    ::capnp::Orphan< ::fsc::ToroidalGrid>&& value) {
  ::capnp::_::PointerHelpers< ::fsc::ToroidalGrid>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fsc::ToroidalGrid> FLTKernelRequest::Builder::disownGrid() {
  return ::capnp::_::PointerHelpers< ::fsc::ToroidalGrid>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool FLTKernelRequest::Reader::hasFieldData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool FLTKernelRequest::Builder::hasFieldData() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::fsc::Float64Tensor::Reader FLTKernelRequest::Reader::getFieldData() const {
  return ::capnp::_::PointerHelpers< ::fsc::Float64Tensor>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::fsc::Float64Tensor::Builder FLTKernelRequest::Builder::getFieldData() {
  return ::capnp::_::PointerHelpers< ::fsc::Float64Tensor>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fsc::Float64Tensor::Pipeline FLTKernelRequest::Pipeline::getFieldData() {
  return  ::fsc::Float64Tensor::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void FLTKernelRequest::Builder::setFieldData( ::fsc::Float64Tensor::Reader value) {
  ::capnp::_::PointerHelpers< ::fsc::Float64Tensor>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::fsc::Float64Tensor::Builder FLTKernelRequest::Builder::initFieldData() {
  return ::capnp::_::PointerHelpers< ::fsc::Float64Tensor>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void FLTKernelRequest::Builder::adoptFieldData(
    ::capnp::Orphan< ::fsc::Float64Tensor>&& value) {
  ::capnp::_::PointerHelpers< ::fsc::Float64Tensor>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fsc::Float64Tensor> FLTKernelRequest::Builder::disownFieldData() {
  return ::capnp::_::PointerHelpers< ::fsc::Float64Tensor>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

}  // namespace

CAPNP_END_HEADER

