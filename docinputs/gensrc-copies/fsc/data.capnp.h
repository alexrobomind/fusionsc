// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: data.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#if CAPNP_VERSION != 9001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(c85b8a7758032008);
CAPNP_DECLARE_SCHEMA(987f9a97ddb1d9ac);
CAPNP_DECLARE_SCHEMA(c2328067e8be2f1d);
CAPNP_DECLARE_SCHEMA(f5bcd72e4eafac9b);
CAPNP_DECLARE_SCHEMA(caa68724bceecd24);
CAPNP_DECLARE_SCHEMA(c1faeff39a1791ec);
CAPNP_DECLARE_SCHEMA(80f173987a0eda1f);
CAPNP_DECLARE_SCHEMA(dfe447654b61da44);
CAPNP_DECLARE_SCHEMA(803de9dc208ca739);
CAPNP_DECLARE_SCHEMA(e665b0c0f7806137);
CAPNP_DECLARE_SCHEMA(c6d800d2ed4fcb33);
CAPNP_DECLARE_SCHEMA(e3198e7e815c3f1d);
CAPNP_DECLARE_SCHEMA(ee498f3025b6138b);
CAPNP_DECLARE_SCHEMA(e3343bd2ddce735d);
CAPNP_DECLARE_SCHEMA(ac2540aee80249f2);
CAPNP_DECLARE_SCHEMA(a446c7e0ae9a6b7c);
CAPNP_DECLARE_SCHEMA(c6d48902ddb7e122);
CAPNP_DECLARE_SCHEMA(94f450018e226986);
CAPNP_DECLARE_SCHEMA(92d2138cd3122bc3);
CAPNP_DECLARE_SCHEMA(8624f871b2a83b18);
CAPNP_DECLARE_SCHEMA(bf78c5ee2bb7dba3);
CAPNP_DECLARE_SCHEMA(eda4f7157f306e3e);
CAPNP_DECLARE_SCHEMA(ce6dcc82e239b77b);
CAPNP_DECLARE_SCHEMA(a0d58e813a080128);
CAPNP_DECLARE_SCHEMA(d8b41f6f25e7fcc0);
CAPNP_DECLARE_SCHEMA(d030dd4f26690740);
CAPNP_DECLARE_SCHEMA(fa62ebf34d231755);
CAPNP_DECLARE_SCHEMA(eb6290d07cff7721);
CAPNP_DECLARE_SCHEMA(f229943265589017);
CAPNP_DECLARE_SCHEMA(b99928e5f0483045);
CAPNP_DECLARE_SCHEMA(e0e3b9db82552046);
CAPNP_DECLARE_SCHEMA(e94cdc9a58f345a8);
CAPNP_DECLARE_SCHEMA(873fbce7ac04b2fa);
CAPNP_DECLARE_SCHEMA(e58f80c73717e663);

}  // namespace schemas
}  // namespace capnp

namespace fsc {

template <typename T = ::capnp::AnyPointer>
struct DataRef {
  DataRef() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct Metadata;
  struct Receiver;
  struct MetadataParams;
  struct MetadataResults;
  struct RawBytesParams;
  struct RawBytesResults;
  struct CapTableParams;
  struct CapTableResults;
  struct TransmitParams;
  struct TransmitResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(c85b8a7758032008)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename T>
struct DataRef<T>::Metadata {
  Metadata() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(987f9a97ddb1d9ac, 3, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct DataRef<T>::Receiver {
  Receiver() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct BeginParams;
  struct BeginResults;
  struct ReceiveParams;
  struct DoneParams;
  struct DoneResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(c2328067e8be2f1d)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename T>
struct DataRef<T>::Receiver::BeginParams {
  BeginParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f5bcd72e4eafac9b, 1, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct DataRef<T>::Receiver::BeginResults {
  BeginResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(caa68724bceecd24, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct DataRef<T>::Receiver::ReceiveParams {
  ReceiveParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c1faeff39a1791ec, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct DataRef<T>::Receiver::DoneParams {
  DoneParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(80f173987a0eda1f, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct DataRef<T>::Receiver::DoneResults {
  DoneResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dfe447654b61da44, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct DataRef<T>::MetadataParams {
  MetadataParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(803de9dc208ca739, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct DataRef<T>::MetadataResults {
  MetadataResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e665b0c0f7806137, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct DataRef<T>::RawBytesParams {
  RawBytesParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c6d800d2ed4fcb33, 2, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct DataRef<T>::RawBytesResults {
  RawBytesResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e3198e7e815c3f1d, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct DataRef<T>::CapTableParams {
  CapTableParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ee498f3025b6138b, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct DataRef<T>::CapTableResults {
  CapTableResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e3343bd2ddce735d, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct DataRef<T>::TransmitParams {
  TransmitParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ac2540aee80249f2, 2, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct DataRef<T>::TransmitResults {
  TransmitResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a446c7e0ae9a6b7c, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct DataService {
  DataService() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  template <typename T = ::capnp::AnyPointer>
  struct StoreParams;
  template <typename T = ::capnp::AnyPointer>
  struct StoreResults;
  template <typename T = ::capnp::AnyPointer>
  struct CloneParams;
  template <typename T = ::capnp::AnyPointer>
  struct CloneResults;
  template <typename T = ::capnp::AnyPointer>
  struct CacheParams;
  template <typename T = ::capnp::AnyPointer>
  struct CacheResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(c6d48902ddb7e122)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

template <typename T>
struct DataService::StoreParams {
  StoreParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(94f450018e226986, 0, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct DataService::StoreResults {
  StoreResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(92d2138cd3122bc3, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct DataService::CloneParams {
  CloneParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8624f871b2a83b18, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct DataService::CloneResults {
  CloneResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bf78c5ee2bb7dba3, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct DataService::CacheParams {
  CacheParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eda4f7157f306e3e, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct DataService::CacheResults {
  CacheResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ce6dcc82e239b77b, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct Archive {
  Archive() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct CapabilityInfo;
  struct Entry;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a0d58e813a080128, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Archive::CapabilityInfo {
  CapabilityInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct DataRefInfo;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d8b41f6f25e7fcc0, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Archive::CapabilityInfo::DataRefInfo {
  DataRefInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    NO_DATA_REF,
    REF_I_D,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d030dd4f26690740, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Archive::Entry {
  Entry() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fa62ebf34d231755, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Float64Tensor {
  Float64Tensor() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eb6290d07cff7721, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Float32Tensor {
  Float32Tensor() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f229943265589017, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Int64Tensor {
  Int64Tensor() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b99928e5f0483045, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct UInt64Tensor {
  UInt64Tensor() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e0e3b9db82552046, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Int32Tensor {
  Int32Tensor() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e94cdc9a58f345a8, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct UInt32Tensor {
  UInt32Tensor() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(873fbce7ac04b2fa, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename ListType = ::capnp::AnyPointer>
struct ShapedList {
  ShapedList() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e58f80c73717e663, 0, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, ListType>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

#if !CAPNP_LITE
template <typename T>
class DataRef<T>::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef DataRef Calls;
  typedef DataRef Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::Client asGeneric() {
    return castAs<DataRef<T2>>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::fsc::DataRef<T>::MetadataParams, typename  ::fsc::DataRef<T>::MetadataResults>) metadataRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::fsc::DataRef<T>::RawBytesParams, typename  ::fsc::DataRef<T>::RawBytesResults>) rawBytesRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::fsc::DataRef<T>::CapTableParams, typename  ::fsc::DataRef<T>::CapTableResults>) capTableRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::fsc::DataRef<T>::TransmitParams, typename  ::fsc::DataRef<T>::TransmitResults>) transmitRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename T>
class DataRef<T>::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef DataRef Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::fsc::DataRef<T>::MetadataParams MetadataParams;
  typedef typename  ::fsc::DataRef<T>::MetadataResults MetadataResults;
  typedef ::capnp::CallContext<MetadataParams, MetadataResults> MetadataContext;
  virtual ::kj::Promise<void> metadata(MetadataContext context);
  typedef typename  ::fsc::DataRef<T>::RawBytesParams RawBytesParams;
  typedef typename  ::fsc::DataRef<T>::RawBytesResults RawBytesResults;
  typedef ::capnp::CallContext<RawBytesParams, RawBytesResults> RawBytesContext;
  virtual ::kj::Promise<void> rawBytes(RawBytesContext context);
  typedef typename  ::fsc::DataRef<T>::CapTableParams CapTableParams;
  typedef typename  ::fsc::DataRef<T>::CapTableResults CapTableResults;
  typedef ::capnp::CallContext<CapTableParams, CapTableResults> CapTableContext;
  virtual ::kj::Promise<void> capTable(CapTableContext context);
  typedef typename  ::fsc::DataRef<T>::TransmitParams TransmitParams;
  typedef typename  ::fsc::DataRef<T>::TransmitResults TransmitResults;
  typedef ::capnp::CallContext<TransmitParams, TransmitResults> TransmitContext;
  virtual ::kj::Promise<void> transmit(TransmitContext context);

  inline typename  ::fsc::DataRef<T>::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::fsc::DataRef<T>>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename T>
class DataRef<T>::Metadata::Reader {
public:
  typedef Metadata Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::Metadata::Reader asDataRefGeneric() {
    return typename DataRef<T2>::Metadata::Reader(_reader);
  }

  inline bool hasId() const;
  inline  ::capnp::Data::Reader getId() const;

  inline  ::uint64_t getTypeId() const;

  inline  ::uint64_t getCapTableSize() const;

  inline  ::uint64_t getDataSize() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class DataRef<T>::Metadata::Builder {
public:
  typedef Metadata Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::Metadata::Builder asDataRefGeneric() {
    return typename DataRef<T2>::Metadata::Builder(_builder);
  }

  inline bool hasId();
  inline  ::capnp::Data::Builder getId();
  inline void setId( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initId(unsigned int size);
  inline void adoptId(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownId();

  inline  ::uint64_t getTypeId();
  inline void setTypeId( ::uint64_t value);

  inline  ::uint64_t getCapTableSize();
  inline void setCapTableSize( ::uint64_t value);

  inline  ::uint64_t getDataSize();
  inline void setDataSize( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class DataRef<T>::Metadata::Pipeline {
public:
  typedef Metadata Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename T>
class DataRef<T>::Receiver::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Receiver Calls;
  typedef Receiver Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::Receiver::Client asDataRefGeneric() {
    return castAs<typename DataRef<T2>::Receiver>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::fsc::DataRef<T>::Receiver::BeginParams, typename  ::fsc::DataRef<T>::Receiver::BeginResults>) beginRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::StreamingRequest<typename  ::fsc::DataRef<T>::Receiver::ReceiveParams>) receiveRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::fsc::DataRef<T>::Receiver::DoneParams, typename  ::fsc::DataRef<T>::Receiver::DoneResults>) doneRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename T>
class DataRef<T>::Receiver::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Receiver Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::fsc::DataRef<T>::Receiver::BeginParams BeginParams;
  typedef typename  ::fsc::DataRef<T>::Receiver::BeginResults BeginResults;
  typedef ::capnp::CallContext<BeginParams, BeginResults> BeginContext;
  virtual ::kj::Promise<void> begin(BeginContext context);
  typedef typename  ::fsc::DataRef<T>::Receiver::ReceiveParams ReceiveParams;
  typedef ::capnp::StreamingCallContext<ReceiveParams> ReceiveContext;
  virtual ::kj::Promise<void> receive(ReceiveContext context);
  typedef typename  ::fsc::DataRef<T>::Receiver::DoneParams DoneParams;
  typedef typename  ::fsc::DataRef<T>::Receiver::DoneResults DoneResults;
  typedef ::capnp::CallContext<DoneParams, DoneResults> DoneContext;
  virtual ::kj::Promise<void> done(DoneContext context);

  inline typename  ::fsc::DataRef<T>::Receiver::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs<typename  ::fsc::DataRef<T>::Receiver>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename T>
class DataRef<T>::Receiver::BeginParams::Reader {
public:
  typedef BeginParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::Receiver::Reader asDataRefGeneric() {
    return typename DataRef<T2>::Receiver::Reader(_reader);
  }

  inline  ::uint64_t getNumBytes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class DataRef<T>::Receiver::BeginParams::Builder {
public:
  typedef BeginParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::Receiver::Builder asDataRefGeneric() {
    return typename DataRef<T2>::Receiver::Builder(_builder);
  }

  inline  ::uint64_t getNumBytes();
  inline void setNumBytes( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class DataRef<T>::Receiver::BeginParams::Pipeline {
public:
  typedef BeginParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class DataRef<T>::Receiver::BeginResults::Reader {
public:
  typedef BeginResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::Receiver::Reader asDataRefGeneric() {
    return typename DataRef<T2>::Receiver::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class DataRef<T>::Receiver::BeginResults::Builder {
public:
  typedef BeginResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::Receiver::Builder asDataRefGeneric() {
    return typename DataRef<T2>::Receiver::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class DataRef<T>::Receiver::BeginResults::Pipeline {
public:
  typedef BeginResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class DataRef<T>::Receiver::ReceiveParams::Reader {
public:
  typedef ReceiveParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::Receiver::Reader asDataRefGeneric() {
    return typename DataRef<T2>::Receiver::Reader(_reader);
  }

  inline bool hasData() const;
  inline  ::capnp::Data::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class DataRef<T>::Receiver::ReceiveParams::Builder {
public:
  typedef ReceiveParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::Receiver::Builder asDataRefGeneric() {
    return typename DataRef<T2>::Receiver::Builder(_builder);
  }

  inline bool hasData();
  inline  ::capnp::Data::Builder getData();
  inline void setData( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class DataRef<T>::Receiver::ReceiveParams::Pipeline {
public:
  typedef ReceiveParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class DataRef<T>::Receiver::DoneParams::Reader {
public:
  typedef DoneParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::Receiver::Reader asDataRefGeneric() {
    return typename DataRef<T2>::Receiver::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class DataRef<T>::Receiver::DoneParams::Builder {
public:
  typedef DoneParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::Receiver::Builder asDataRefGeneric() {
    return typename DataRef<T2>::Receiver::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class DataRef<T>::Receiver::DoneParams::Pipeline {
public:
  typedef DoneParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class DataRef<T>::Receiver::DoneResults::Reader {
public:
  typedef DoneResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::Receiver::Reader asDataRefGeneric() {
    return typename DataRef<T2>::Receiver::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class DataRef<T>::Receiver::DoneResults::Builder {
public:
  typedef DoneResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::Receiver::Builder asDataRefGeneric() {
    return typename DataRef<T2>::Receiver::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class DataRef<T>::Receiver::DoneResults::Pipeline {
public:
  typedef DoneResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class DataRef<T>::MetadataParams::Reader {
public:
  typedef MetadataParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::MetadataParams::Reader asDataRefGeneric() {
    return typename DataRef<T2>::MetadataParams::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class DataRef<T>::MetadataParams::Builder {
public:
  typedef MetadataParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::MetadataParams::Builder asDataRefGeneric() {
    return typename DataRef<T2>::MetadataParams::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class DataRef<T>::MetadataParams::Pipeline {
public:
  typedef MetadataParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class DataRef<T>::MetadataResults::Reader {
public:
  typedef MetadataResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::MetadataResults::Reader asDataRefGeneric() {
    return typename DataRef<T2>::MetadataResults::Reader(_reader);
  }

  inline bool hasMetadata() const;
  inline typename  ::fsc::DataRef<T>::Metadata::Reader getMetadata() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class DataRef<T>::MetadataResults::Builder {
public:
  typedef MetadataResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::MetadataResults::Builder asDataRefGeneric() {
    return typename DataRef<T2>::MetadataResults::Builder(_builder);
  }

  inline bool hasMetadata();
  inline typename  ::fsc::DataRef<T>::Metadata::Builder getMetadata();
  inline void setMetadata(typename  ::fsc::DataRef<T>::Metadata::Reader value);
  inline typename  ::fsc::DataRef<T>::Metadata::Builder initMetadata();
  inline void adoptMetadata(::capnp::Orphan<typename  ::fsc::DataRef<T>::Metadata>&& value);
  inline ::capnp::Orphan<typename  ::fsc::DataRef<T>::Metadata> disownMetadata();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class DataRef<T>::MetadataResults::Pipeline {
public:
  typedef MetadataResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename  ::fsc::DataRef<T>::Metadata::Pipeline getMetadata();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class DataRef<T>::RawBytesParams::Reader {
public:
  typedef RawBytesParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::RawBytesParams::Reader asDataRefGeneric() {
    return typename DataRef<T2>::RawBytesParams::Reader(_reader);
  }

  inline  ::uint64_t getStart() const;

  inline  ::uint64_t getEnd() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class DataRef<T>::RawBytesParams::Builder {
public:
  typedef RawBytesParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::RawBytesParams::Builder asDataRefGeneric() {
    return typename DataRef<T2>::RawBytesParams::Builder(_builder);
  }

  inline  ::uint64_t getStart();
  inline void setStart( ::uint64_t value);

  inline  ::uint64_t getEnd();
  inline void setEnd( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class DataRef<T>::RawBytesParams::Pipeline {
public:
  typedef RawBytesParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class DataRef<T>::RawBytesResults::Reader {
public:
  typedef RawBytesResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::RawBytesResults::Reader asDataRefGeneric() {
    return typename DataRef<T2>::RawBytesResults::Reader(_reader);
  }

  inline bool hasData() const;
  inline  ::capnp::Data::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class DataRef<T>::RawBytesResults::Builder {
public:
  typedef RawBytesResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::RawBytesResults::Builder asDataRefGeneric() {
    return typename DataRef<T2>::RawBytesResults::Builder(_builder);
  }

  inline bool hasData();
  inline  ::capnp::Data::Builder getData();
  inline void setData( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class DataRef<T>::RawBytesResults::Pipeline {
public:
  typedef RawBytesResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class DataRef<T>::CapTableParams::Reader {
public:
  typedef CapTableParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::CapTableParams::Reader asDataRefGeneric() {
    return typename DataRef<T2>::CapTableParams::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class DataRef<T>::CapTableParams::Builder {
public:
  typedef CapTableParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::CapTableParams::Builder asDataRefGeneric() {
    return typename DataRef<T2>::CapTableParams::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class DataRef<T>::CapTableParams::Pipeline {
public:
  typedef CapTableParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class DataRef<T>::CapTableResults::Reader {
public:
  typedef CapTableResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::CapTableResults::Reader asDataRefGeneric() {
    return typename DataRef<T2>::CapTableResults::Reader(_reader);
  }

  inline bool hasTable() const;
#if !CAPNP_LITE
  inline  ::capnp::List< ::capnp::Capability,  ::capnp::Kind::INTERFACE>::Reader getTable() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class DataRef<T>::CapTableResults::Builder {
public:
  typedef CapTableResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::CapTableResults::Builder asDataRefGeneric() {
    return typename DataRef<T2>::CapTableResults::Builder(_builder);
  }

  inline bool hasTable();
#if !CAPNP_LITE
  inline  ::capnp::List< ::capnp::Capability,  ::capnp::Kind::INTERFACE>::Builder getTable();
  inline void setTable( ::capnp::List< ::capnp::Capability,  ::capnp::Kind::INTERFACE>::Reader value);
  inline  ::capnp::List< ::capnp::Capability,  ::capnp::Kind::INTERFACE>::Builder initTable(unsigned int size);
  inline void adoptTable(::capnp::Orphan< ::capnp::List< ::capnp::Capability,  ::capnp::Kind::INTERFACE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Capability,  ::capnp::Kind::INTERFACE>> disownTable();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class DataRef<T>::CapTableResults::Pipeline {
public:
  typedef CapTableResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class DataRef<T>::TransmitParams::Reader {
public:
  typedef TransmitParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::TransmitParams::Reader asDataRefGeneric() {
    return typename DataRef<T2>::TransmitParams::Reader(_reader);
  }

  inline  ::uint64_t getStart() const;

  inline  ::uint64_t getEnd() const;

  inline bool hasReceiver() const;
#if !CAPNP_LITE
  inline typename  ::fsc::DataRef<T>::Receiver::Client getReceiver() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class DataRef<T>::TransmitParams::Builder {
public:
  typedef TransmitParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::TransmitParams::Builder asDataRefGeneric() {
    return typename DataRef<T2>::TransmitParams::Builder(_builder);
  }

  inline  ::uint64_t getStart();
  inline void setStart( ::uint64_t value);

  inline  ::uint64_t getEnd();
  inline void setEnd( ::uint64_t value);

  inline bool hasReceiver();
#if !CAPNP_LITE
  inline typename  ::fsc::DataRef<T>::Receiver::Client getReceiver();
  inline void setReceiver(typename  ::fsc::DataRef<T>::Receiver::Client&& value);
  inline void setReceiver(typename  ::fsc::DataRef<T>::Receiver::Client& value);
  inline void adoptReceiver(::capnp::Orphan<typename  ::fsc::DataRef<T>::Receiver>&& value);
  inline ::capnp::Orphan<typename  ::fsc::DataRef<T>::Receiver> disownReceiver();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class DataRef<T>::TransmitParams::Pipeline {
public:
  typedef TransmitParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename  ::fsc::DataRef<T>::Receiver::Client getReceiver();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class DataRef<T>::TransmitResults::Reader {
public:
  typedef TransmitResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::TransmitResults::Reader asDataRefGeneric() {
    return typename DataRef<T2>::TransmitResults::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class DataRef<T>::TransmitResults::Builder {
public:
  typedef TransmitResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename DataRef<T2>::TransmitResults::Builder asDataRefGeneric() {
    return typename DataRef<T2>::TransmitResults::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class DataRef<T>::TransmitResults::Pipeline {
public:
  typedef TransmitResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class DataService::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef DataService Calls;
  typedef DataService Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename T>
  ::capnp::Request< ::fsc::DataService::StoreParams<T>,  ::fsc::DataService::StoreResults<T>> storeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  template <typename T>
  ::capnp::Request< ::fsc::DataService::CloneParams<T>,  ::fsc::DataService::CloneResults<T>> cloneRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  template <typename T>
  ::capnp::Request< ::fsc::DataService::CacheParams<T>,  ::fsc::DataService::CacheResults<T>> cacheRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class DataService::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef DataService Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::fsc::DataService::StoreParams<> StoreParams;
  typedef  ::fsc::DataService::StoreResults<> StoreResults;
  typedef ::capnp::CallContext<StoreParams, StoreResults> StoreContext;
  virtual ::kj::Promise<void> store(StoreContext context);
  typedef  ::fsc::DataService::CloneParams<> CloneParams;
  typedef  ::fsc::DataService::CloneResults<> CloneResults;
  typedef ::capnp::CallContext<CloneParams, CloneResults> CloneContext;
  virtual ::kj::Promise<void> clone(CloneContext context);
  typedef  ::fsc::DataService::CacheParams<> CacheParams;
  typedef  ::fsc::DataService::CacheResults<> CacheResults;
  typedef ::capnp::CallContext<CacheParams, CacheResults> CacheContext;
  virtual ::kj::Promise<void> cache(CacheContext context);

  inline  ::fsc::DataService::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::fsc::DataService>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename T>
class DataService::StoreParams<T>::Reader {
public:
  typedef StoreParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename StoreParams<T2>::Reader asGeneric() {
    return typename StoreParams<T2>::Reader(_reader);
  }

  inline bool hasId() const;
  inline  ::capnp::Data::Reader getId() const;

  inline bool hasData() const;
  inline  ::capnp::ReaderFor<T> getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class DataService::StoreParams<T>::Builder {
public:
  typedef StoreParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename StoreParams<T2>::Builder asGeneric() {
    return typename StoreParams<T2>::Builder(_builder);
  }

  inline bool hasId();
  inline  ::capnp::Data::Builder getId();
  inline void setId( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initId(unsigned int size);
  inline void adoptId(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownId();

  inline bool hasData();
  inline  ::capnp::BuilderFor<T> getData();
  inline void setData( ::capnp::ReaderFor<T> value);
  inline  ::capnp::BuilderFor<T> initData();
  inline  ::capnp::BuilderFor<T> initData(unsigned int size);
  inline void adoptData(::capnp::Orphan<T>&& value);
  inline ::capnp::Orphan<T> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class DataService::StoreParams<T>::Pipeline {
public:
  typedef StoreParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<T> getData();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class DataService::StoreResults<T>::Reader {
public:
  typedef StoreResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename StoreResults<T2>::Reader asGeneric() {
    return typename StoreResults<T2>::Reader(_reader);
  }

  inline bool hasRef() const;
#if !CAPNP_LITE
  inline typename  ::fsc::DataRef<T>::Client getRef() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class DataService::StoreResults<T>::Builder {
public:
  typedef StoreResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename StoreResults<T2>::Builder asGeneric() {
    return typename StoreResults<T2>::Builder(_builder);
  }

  inline bool hasRef();
#if !CAPNP_LITE
  inline typename  ::fsc::DataRef<T>::Client getRef();
  inline void setRef(typename  ::fsc::DataRef<T>::Client&& value);
  inline void setRef(typename  ::fsc::DataRef<T>::Client& value);
  inline void adoptRef(::capnp::Orphan< ::fsc::DataRef<T>>&& value);
  inline ::capnp::Orphan< ::fsc::DataRef<T>> disownRef();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class DataService::StoreResults<T>::Pipeline {
public:
  typedef StoreResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename  ::fsc::DataRef<T>::Client getRef();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class DataService::CloneParams<T>::Reader {
public:
  typedef CloneParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename CloneParams<T2>::Reader asGeneric() {
    return typename CloneParams<T2>::Reader(_reader);
  }

  inline bool hasSource() const;
#if !CAPNP_LITE
  inline typename  ::fsc::DataRef<T>::Client getSource() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class DataService::CloneParams<T>::Builder {
public:
  typedef CloneParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename CloneParams<T2>::Builder asGeneric() {
    return typename CloneParams<T2>::Builder(_builder);
  }

  inline bool hasSource();
#if !CAPNP_LITE
  inline typename  ::fsc::DataRef<T>::Client getSource();
  inline void setSource(typename  ::fsc::DataRef<T>::Client&& value);
  inline void setSource(typename  ::fsc::DataRef<T>::Client& value);
  inline void adoptSource(::capnp::Orphan< ::fsc::DataRef<T>>&& value);
  inline ::capnp::Orphan< ::fsc::DataRef<T>> disownSource();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class DataService::CloneParams<T>::Pipeline {
public:
  typedef CloneParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename  ::fsc::DataRef<T>::Client getSource();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class DataService::CloneResults<T>::Reader {
public:
  typedef CloneResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename CloneResults<T2>::Reader asGeneric() {
    return typename CloneResults<T2>::Reader(_reader);
  }

  inline bool hasRef() const;
#if !CAPNP_LITE
  inline typename  ::fsc::DataRef<T>::Client getRef() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class DataService::CloneResults<T>::Builder {
public:
  typedef CloneResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename CloneResults<T2>::Builder asGeneric() {
    return typename CloneResults<T2>::Builder(_builder);
  }

  inline bool hasRef();
#if !CAPNP_LITE
  inline typename  ::fsc::DataRef<T>::Client getRef();
  inline void setRef(typename  ::fsc::DataRef<T>::Client&& value);
  inline void setRef(typename  ::fsc::DataRef<T>::Client& value);
  inline void adoptRef(::capnp::Orphan< ::fsc::DataRef<T>>&& value);
  inline ::capnp::Orphan< ::fsc::DataRef<T>> disownRef();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class DataService::CloneResults<T>::Pipeline {
public:
  typedef CloneResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename  ::fsc::DataRef<T>::Client getRef();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class DataService::CacheParams<T>::Reader {
public:
  typedef CacheParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename CacheParams<T2>::Reader asGeneric() {
    return typename CacheParams<T2>::Reader(_reader);
  }

  inline bool hasSource() const;
#if !CAPNP_LITE
  inline typename  ::fsc::DataRef<T>::Client getSource() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class DataService::CacheParams<T>::Builder {
public:
  typedef CacheParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename CacheParams<T2>::Builder asGeneric() {
    return typename CacheParams<T2>::Builder(_builder);
  }

  inline bool hasSource();
#if !CAPNP_LITE
  inline typename  ::fsc::DataRef<T>::Client getSource();
  inline void setSource(typename  ::fsc::DataRef<T>::Client&& value);
  inline void setSource(typename  ::fsc::DataRef<T>::Client& value);
  inline void adoptSource(::capnp::Orphan< ::fsc::DataRef<T>>&& value);
  inline ::capnp::Orphan< ::fsc::DataRef<T>> disownSource();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class DataService::CacheParams<T>::Pipeline {
public:
  typedef CacheParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename  ::fsc::DataRef<T>::Client getSource();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class DataService::CacheResults<T>::Reader {
public:
  typedef CacheResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename CacheResults<T2>::Reader asGeneric() {
    return typename CacheResults<T2>::Reader(_reader);
  }

  inline bool hasRef() const;
#if !CAPNP_LITE
  inline typename  ::fsc::DataRef<T>::Client getRef() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class DataService::CacheResults<T>::Builder {
public:
  typedef CacheResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename CacheResults<T2>::Builder asGeneric() {
    return typename CacheResults<T2>::Builder(_builder);
  }

  inline bool hasRef();
#if !CAPNP_LITE
  inline typename  ::fsc::DataRef<T>::Client getRef();
  inline void setRef(typename  ::fsc::DataRef<T>::Client&& value);
  inline void setRef(typename  ::fsc::DataRef<T>::Client& value);
  inline void adoptRef(::capnp::Orphan< ::fsc::DataRef<T>>&& value);
  inline ::capnp::Orphan< ::fsc::DataRef<T>> disownRef();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class DataService::CacheResults<T>::Pipeline {
public:
  typedef CacheResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename  ::fsc::DataRef<T>::Client getRef();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Archive::Reader {
public:
  typedef Archive Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasRoot() const;
  inline  ::fsc::Archive::Entry::Reader getRoot() const;

  inline bool hasExtra() const;
  inline  ::capnp::List< ::fsc::Archive::Entry,  ::capnp::Kind::STRUCT>::Reader getExtra() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Archive::Builder {
public:
  typedef Archive Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasRoot();
  inline  ::fsc::Archive::Entry::Builder getRoot();
  inline void setRoot( ::fsc::Archive::Entry::Reader value);
  inline  ::fsc::Archive::Entry::Builder initRoot();
  inline void adoptRoot(::capnp::Orphan< ::fsc::Archive::Entry>&& value);
  inline ::capnp::Orphan< ::fsc::Archive::Entry> disownRoot();

  inline bool hasExtra();
  inline  ::capnp::List< ::fsc::Archive::Entry,  ::capnp::Kind::STRUCT>::Builder getExtra();
  inline void setExtra( ::capnp::List< ::fsc::Archive::Entry,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::fsc::Archive::Entry,  ::capnp::Kind::STRUCT>::Builder initExtra(unsigned int size);
  inline void adoptExtra(::capnp::Orphan< ::capnp::List< ::fsc::Archive::Entry,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::fsc::Archive::Entry,  ::capnp::Kind::STRUCT>> disownExtra();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Archive::Pipeline {
public:
  typedef Archive Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::fsc::Archive::Entry::Pipeline getRoot();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Archive::CapabilityInfo::Reader {
public:
  typedef CapabilityInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline typename DataRefInfo::Reader getDataRefInfo() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Archive::CapabilityInfo::Builder {
public:
  typedef CapabilityInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline typename DataRefInfo::Builder getDataRefInfo();
  inline typename DataRefInfo::Builder initDataRefInfo();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Archive::CapabilityInfo::Pipeline {
public:
  typedef CapabilityInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename DataRefInfo::Pipeline getDataRefInfo();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Archive::CapabilityInfo::DataRefInfo::Reader {
public:
  typedef DataRefInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isNoDataRef() const;
  inline  ::capnp::Void getNoDataRef() const;

  inline bool isRefID() const;
  inline bool hasRefID() const;
  inline  ::capnp::Data::Reader getRefID() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Archive::CapabilityInfo::DataRefInfo::Builder {
public:
  typedef DataRefInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isNoDataRef();
  inline  ::capnp::Void getNoDataRef();
  inline void setNoDataRef( ::capnp::Void value = ::capnp::VOID);

  inline bool isRefID();
  inline bool hasRefID();
  inline  ::capnp::Data::Builder getRefID();
  inline void setRefID( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initRefID(unsigned int size);
  inline void adoptRefID(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownRefID();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Archive::CapabilityInfo::DataRefInfo::Pipeline {
public:
  typedef DataRefInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Archive::Entry::Reader {
public:
  typedef Entry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasId() const;
  inline  ::capnp::Data::Reader getId() const;

  inline bool hasData() const;
  inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Reader getData() const;

  inline bool hasCapabilities() const;
  inline  ::capnp::List< ::fsc::Archive::CapabilityInfo,  ::capnp::Kind::STRUCT>::Reader getCapabilities() const;

  inline  ::uint64_t getTypeId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Archive::Entry::Builder {
public:
  typedef Entry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasId();
  inline  ::capnp::Data::Builder getId();
  inline void setId( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initId(unsigned int size);
  inline void adoptId(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownId();

  inline bool hasData();
  inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Builder getData();
  inline void setData( ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Reader value);
  inline void setData(::kj::ArrayPtr<const  ::capnp::Data::Reader> value);
  inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>> disownData();

  inline bool hasCapabilities();
  inline  ::capnp::List< ::fsc::Archive::CapabilityInfo,  ::capnp::Kind::STRUCT>::Builder getCapabilities();
  inline void setCapabilities( ::capnp::List< ::fsc::Archive::CapabilityInfo,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::fsc::Archive::CapabilityInfo,  ::capnp::Kind::STRUCT>::Builder initCapabilities(unsigned int size);
  inline void adoptCapabilities(::capnp::Orphan< ::capnp::List< ::fsc::Archive::CapabilityInfo,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::fsc::Archive::CapabilityInfo,  ::capnp::Kind::STRUCT>> disownCapabilities();

  inline  ::uint64_t getTypeId();
  inline void setTypeId( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Archive::Entry::Pipeline {
public:
  typedef Entry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Float64Tensor::Reader {
public:
  typedef Float64Tensor Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasShape() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getShape() const;

  inline bool hasData() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Float64Tensor::Builder {
public:
  typedef Float64Tensor Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasShape();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getShape();
  inline void setShape( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setShape(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initShape(unsigned int size);
  inline void adoptShape(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownShape();

  inline bool hasData();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getData();
  inline void setData( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setData(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Float64Tensor::Pipeline {
public:
  typedef Float64Tensor Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Float32Tensor::Reader {
public:
  typedef Float32Tensor Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasShape() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getShape() const;

  inline bool hasData() const;
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Float32Tensor::Builder {
public:
  typedef Float32Tensor Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasShape();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getShape();
  inline void setShape( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setShape(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initShape(unsigned int size);
  inline void adoptShape(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownShape();

  inline bool hasData();
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder getData();
  inline void setData( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setData(::kj::ArrayPtr<const float> value);
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Float32Tensor::Pipeline {
public:
  typedef Float32Tensor Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Int64Tensor::Reader {
public:
  typedef Int64Tensor Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasShape() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getShape() const;

  inline bool hasData() const;
  inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Int64Tensor::Builder {
public:
  typedef Int64Tensor Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasShape();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getShape();
  inline void setShape( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setShape(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initShape(unsigned int size);
  inline void adoptShape(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownShape();

  inline bool hasData();
  inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Builder getData();
  inline void setData( ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setData(::kj::ArrayPtr<const  ::int64_t> value);
  inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Int64Tensor::Pipeline {
public:
  typedef Int64Tensor Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class UInt64Tensor::Reader {
public:
  typedef UInt64Tensor Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasShape() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getShape() const;

  inline bool hasData() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UInt64Tensor::Builder {
public:
  typedef UInt64Tensor Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasShape();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getShape();
  inline void setShape( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setShape(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initShape(unsigned int size);
  inline void adoptShape(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownShape();

  inline bool hasData();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getData();
  inline void setData( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setData(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UInt64Tensor::Pipeline {
public:
  typedef UInt64Tensor Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Int32Tensor::Reader {
public:
  typedef Int32Tensor Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasShape() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getShape() const;

  inline bool hasData() const;
  inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Int32Tensor::Builder {
public:
  typedef Int32Tensor Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasShape();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getShape();
  inline void setShape( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setShape(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initShape(unsigned int size);
  inline void adoptShape(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownShape();

  inline bool hasData();
  inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Builder getData();
  inline void setData( ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setData(::kj::ArrayPtr<const  ::int32_t> value);
  inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Int32Tensor::Pipeline {
public:
  typedef Int32Tensor Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class UInt32Tensor::Reader {
public:
  typedef UInt32Tensor Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasShape() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getShape() const;

  inline bool hasData() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UInt32Tensor::Builder {
public:
  typedef UInt32Tensor Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasShape();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getShape();
  inline void setShape( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setShape(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initShape(unsigned int size);
  inline void adoptShape(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownShape();

  inline bool hasData();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getData();
  inline void setData( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setData(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UInt32Tensor::Pipeline {
public:
  typedef UInt32Tensor Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename ListType>
class ShapedList<ListType>::Reader {
public:
  typedef ShapedList Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename ListType2 = ::capnp::AnyPointer>
  typename ShapedList<ListType2>::Reader asGeneric() {
    return typename ShapedList<ListType2>::Reader(_reader);
  }

  inline bool hasShape() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getShape() const;

  inline bool hasData() const;
  inline  ::capnp::ReaderFor<ListType> getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename ListType>
class ShapedList<ListType>::Builder {
public:
  typedef ShapedList Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename ListType2 = ::capnp::AnyPointer>
  typename ShapedList<ListType2>::Builder asGeneric() {
    return typename ShapedList<ListType2>::Builder(_builder);
  }

  inline bool hasShape();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getShape();
  inline void setShape( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setShape(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initShape(unsigned int size);
  inline void adoptShape(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownShape();

  inline bool hasData();
  inline  ::capnp::BuilderFor<ListType> getData();
  inline void setData( ::capnp::ReaderFor<ListType> value);
  inline  ::capnp::BuilderFor<ListType> initData();
  inline  ::capnp::BuilderFor<ListType> initData(unsigned int size);
  inline void adoptData(::capnp::Orphan<ListType>&& value);
  inline ::capnp::Orphan<ListType> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename ListType>
class ShapedList<ListType>::Pipeline {
public:
  typedef ShapedList Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<ListType> getData();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

#if !CAPNP_LITE
template <typename T>
inline DataRef<T>::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename T>
inline DataRef<T>::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename T>
template <typename _t, typename>
inline DataRef<T>::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename T>
template <typename _t, typename>
inline DataRef<T>::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename T>
inline DataRef<T>::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename T>
inline typename  ::fsc::DataRef<T>::Client& DataRef<T>::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename T>
inline typename  ::fsc::DataRef<T>::Client& DataRef<T>::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
template <typename T>
inline bool DataRef<T>::Metadata::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool DataRef<T>::Metadata::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline  ::capnp::Data::Reader DataRef<T>::Metadata::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::capnp::Data::Builder DataRef<T>::Metadata::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline void DataRef<T>::Metadata::Builder::setId( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename T>
inline  ::capnp::Data::Builder DataRef<T>::Metadata::Builder::initId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename T>
inline void DataRef<T>::Metadata::Builder::adoptId(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan< ::capnp::Data> DataRef<T>::Metadata::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename T>
inline  ::uint64_t DataRef<T>::Metadata::Reader::getTypeId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename T>
inline  ::uint64_t DataRef<T>::Metadata::Builder::getTypeId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename T>
inline void DataRef<T>::Metadata::Builder::setTypeId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

template <typename T>
inline  ::uint64_t DataRef<T>::Metadata::Reader::getCapTableSize() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

template <typename T>
inline  ::uint64_t DataRef<T>::Metadata::Builder::getCapTableSize() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
template <typename T>
inline void DataRef<T>::Metadata::Builder::setCapTableSize( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

template <typename T>
inline  ::uint64_t DataRef<T>::Metadata::Reader::getDataSize() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

template <typename T>
inline  ::uint64_t DataRef<T>::Metadata::Builder::getDataSize() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
template <typename T>
inline void DataRef<T>::Metadata::Builder::setDataSize( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

// DataRef<T>::Metadata
template <typename T>
constexpr uint16_t DataRef<T>::Metadata::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t DataRef<T>::Metadata::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind DataRef<T>::Metadata::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* DataRef<T>::Metadata::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope DataRef<T>::Metadata::_capnpPrivate::brandScopes[] = {
  { 0xc85b8a7758032008, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding DataRef<T>::Metadata::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema DataRef<T>::Metadata::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_987f9a97ddb1d9ac, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename T>
inline DataRef<T>::Receiver::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename T>
inline DataRef<T>::Receiver::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename T>
template <typename _t, typename>
inline DataRef<T>::Receiver::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename T>
template <typename _t, typename>
inline DataRef<T>::Receiver::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename T>
inline DataRef<T>::Receiver::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename T>
inline typename  ::fsc::DataRef<T>::Receiver::Client& DataRef<T>::Receiver::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename T>
inline typename  ::fsc::DataRef<T>::Receiver::Client& DataRef<T>::Receiver::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
template <typename T>
inline  ::uint64_t DataRef<T>::Receiver::BeginParams::Reader::getNumBytes() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename T>
inline  ::uint64_t DataRef<T>::Receiver::BeginParams::Builder::getNumBytes() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename T>
inline void DataRef<T>::Receiver::BeginParams::Builder::setNumBytes( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

// DataRef<T>::Receiver::BeginParams
template <typename T>
constexpr uint16_t DataRef<T>::Receiver::BeginParams::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t DataRef<T>::Receiver::BeginParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind DataRef<T>::Receiver::BeginParams::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* DataRef<T>::Receiver::BeginParams::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope DataRef<T>::Receiver::BeginParams::_capnpPrivate::brandScopes[] = {
  { 0xc85b8a7758032008, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding DataRef<T>::Receiver::BeginParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema DataRef<T>::Receiver::BeginParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_f5bcd72e4eafac9b, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// DataRef<T>::Receiver::BeginResults
template <typename T>
constexpr uint16_t DataRef<T>::Receiver::BeginResults::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t DataRef<T>::Receiver::BeginResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind DataRef<T>::Receiver::BeginResults::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* DataRef<T>::Receiver::BeginResults::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope DataRef<T>::Receiver::BeginResults::_capnpPrivate::brandScopes[] = {
  { 0xc85b8a7758032008, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding DataRef<T>::Receiver::BeginResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema DataRef<T>::Receiver::BeginResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_caa68724bceecd24, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename T>
inline bool DataRef<T>::Receiver::ReceiveParams::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool DataRef<T>::Receiver::ReceiveParams::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline  ::capnp::Data::Reader DataRef<T>::Receiver::ReceiveParams::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::capnp::Data::Builder DataRef<T>::Receiver::ReceiveParams::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline void DataRef<T>::Receiver::ReceiveParams::Builder::setData( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename T>
inline  ::capnp::Data::Builder DataRef<T>::Receiver::ReceiveParams::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename T>
inline void DataRef<T>::Receiver::ReceiveParams::Builder::adoptData(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan< ::capnp::Data> DataRef<T>::Receiver::ReceiveParams::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// DataRef<T>::Receiver::ReceiveParams
template <typename T>
constexpr uint16_t DataRef<T>::Receiver::ReceiveParams::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t DataRef<T>::Receiver::ReceiveParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind DataRef<T>::Receiver::ReceiveParams::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* DataRef<T>::Receiver::ReceiveParams::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope DataRef<T>::Receiver::ReceiveParams::_capnpPrivate::brandScopes[] = {
  { 0xc85b8a7758032008, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding DataRef<T>::Receiver::ReceiveParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema DataRef<T>::Receiver::ReceiveParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_c1faeff39a1791ec, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// DataRef<T>::Receiver::DoneParams
template <typename T>
constexpr uint16_t DataRef<T>::Receiver::DoneParams::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t DataRef<T>::Receiver::DoneParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind DataRef<T>::Receiver::DoneParams::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* DataRef<T>::Receiver::DoneParams::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope DataRef<T>::Receiver::DoneParams::_capnpPrivate::brandScopes[] = {
  { 0xc85b8a7758032008, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding DataRef<T>::Receiver::DoneParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema DataRef<T>::Receiver::DoneParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_80f173987a0eda1f, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// DataRef<T>::Receiver::DoneResults
template <typename T>
constexpr uint16_t DataRef<T>::Receiver::DoneResults::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t DataRef<T>::Receiver::DoneResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind DataRef<T>::Receiver::DoneResults::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* DataRef<T>::Receiver::DoneResults::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope DataRef<T>::Receiver::DoneResults::_capnpPrivate::brandScopes[] = {
  { 0xc85b8a7758032008, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding DataRef<T>::Receiver::DoneResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema DataRef<T>::Receiver::DoneResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_dfe447654b61da44, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename T>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::fsc::DataRef<T>::Receiver::BeginParams, typename  ::fsc::DataRef<T>::Receiver::BeginResults>)
DataRef<T>::Receiver::Client::beginRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::fsc::DataRef<T>::Receiver::BeginParams, typename  ::fsc::DataRef<T>::Receiver::BeginResults>(
      0xc2328067e8be2f1dull, 0, sizeHint);
}
template <typename T>
::kj::Promise<void> DataRef<T>::Receiver::Server::begin(BeginContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "data.capnp:DataRef.Receiver", "begin",
      0xc2328067e8be2f1dull, 0);
}
template <typename T>
CAPNP_AUTO_IF_MSVC(::capnp::StreamingRequest<typename  ::fsc::DataRef<T>::Receiver::ReceiveParams>)
DataRef<T>::Receiver::Client::receiveRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newStreamingCall<typename  ::fsc::DataRef<T>::Receiver::ReceiveParams>(
      0xc2328067e8be2f1dull, 1, sizeHint);
}
template <typename T>
::kj::Promise<void> DataRef<T>::Receiver::Server::receive(ReceiveContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "data.capnp:DataRef.Receiver", "receive",
      0xc2328067e8be2f1dull, 1);
}
template <typename T>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::fsc::DataRef<T>::Receiver::DoneParams, typename  ::fsc::DataRef<T>::Receiver::DoneResults>)
DataRef<T>::Receiver::Client::doneRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::fsc::DataRef<T>::Receiver::DoneParams, typename  ::fsc::DataRef<T>::Receiver::DoneResults>(
      0xc2328067e8be2f1dull, 2, sizeHint);
}
template <typename T>
::kj::Promise<void> DataRef<T>::Receiver::Server::done(DoneContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "data.capnp:DataRef.Receiver", "done",
      0xc2328067e8be2f1dull, 2);
}
template <typename T>
::capnp::Capability::Server::DispatchCallResult DataRef<T>::Receiver::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0xc2328067e8be2f1dull:
      return dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("data.capnp:DataRef.Receiver", interfaceId);
  }
}
template <typename T>
::capnp::Capability::Server::DispatchCallResult DataRef<T>::Receiver::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return {
        begin(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::fsc::DataRef<T>::Receiver::BeginParams, typename  ::fsc::DataRef<T>::Receiver::BeginResults>(context)),
        false
      };
    case 1:
      return {
        kj::evalNow([&]() {
          return receive(::capnp::Capability::Server::internalGetTypedStreamingContext<
              typename  ::fsc::DataRef<T>::Receiver::ReceiveParams>(context));
        }),
        true
      };
    case 2:
      return {
        done(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::fsc::DataRef<T>::Receiver::DoneParams, typename  ::fsc::DataRef<T>::Receiver::DoneResults>(context)),
        false
      };
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "data.capnp:DataRef.Receiver",
          0xc2328067e8be2f1dull, methodId);
  }
}
#endif  // !CAPNP_LITE

// DataRef<T>::Receiver
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind DataRef<T>::Receiver::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* DataRef<T>::Receiver::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope DataRef<T>::Receiver::_capnpPrivate::brandScopes[] = {
  { 0xc85b8a7758032008, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding DataRef<T>::Receiver::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Dependency DataRef<T>::Receiver::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::fsc::DataRef<T>::Receiver::BeginParams::_capnpPrivate::brand() },
  { 33554433,  ::fsc::DataRef<T>::Receiver::ReceiveParams::_capnpPrivate::brand() },
  { 33554434,  ::fsc::DataRef<T>::Receiver::DoneParams::_capnpPrivate::brand() },
  { 50331648,  ::fsc::DataRef<T>::Receiver::BeginResults::_capnpPrivate::brand() },
  { 50331650,  ::fsc::DataRef<T>::Receiver::DoneResults::_capnpPrivate::brand() },
};
template <typename T>
const ::capnp::_::RawBrandedSchema DataRef<T>::Receiver::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_c2328067e8be2f1d, brandScopes, brandDependencies,
  1, 5, nullptr
};
#endif  // !CAPNP_LITE

// DataRef<T>::MetadataParams
template <typename T>
constexpr uint16_t DataRef<T>::MetadataParams::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t DataRef<T>::MetadataParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind DataRef<T>::MetadataParams::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* DataRef<T>::MetadataParams::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope DataRef<T>::MetadataParams::_capnpPrivate::brandScopes[] = {
  { 0xc85b8a7758032008, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding DataRef<T>::MetadataParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema DataRef<T>::MetadataParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_803de9dc208ca739, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename T>
inline bool DataRef<T>::MetadataResults::Reader::hasMetadata() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool DataRef<T>::MetadataResults::Builder::hasMetadata() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline typename  ::fsc::DataRef<T>::Metadata::Reader DataRef<T>::MetadataResults::Reader::getMetadata() const {
  return ::capnp::_::PointerHelpers<typename  ::fsc::DataRef<T>::Metadata>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline typename  ::fsc::DataRef<T>::Metadata::Builder DataRef<T>::MetadataResults::Builder::getMetadata() {
  return ::capnp::_::PointerHelpers<typename  ::fsc::DataRef<T>::Metadata>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename T>
inline typename  ::fsc::DataRef<T>::Metadata::Pipeline DataRef<T>::MetadataResults::Pipeline::getMetadata() {
  return typename  ::fsc::DataRef<T>::Metadata::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename T>
inline void DataRef<T>::MetadataResults::Builder::setMetadata(typename  ::fsc::DataRef<T>::Metadata::Reader value) {
  ::capnp::_::PointerHelpers<typename  ::fsc::DataRef<T>::Metadata>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename T>
inline typename  ::fsc::DataRef<T>::Metadata::Builder DataRef<T>::MetadataResults::Builder::initMetadata() {
  return ::capnp::_::PointerHelpers<typename  ::fsc::DataRef<T>::Metadata>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline void DataRef<T>::MetadataResults::Builder::adoptMetadata(
    ::capnp::Orphan<typename  ::fsc::DataRef<T>::Metadata>&& value) {
  ::capnp::_::PointerHelpers<typename  ::fsc::DataRef<T>::Metadata>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan<typename  ::fsc::DataRef<T>::Metadata> DataRef<T>::MetadataResults::Builder::disownMetadata() {
  return ::capnp::_::PointerHelpers<typename  ::fsc::DataRef<T>::Metadata>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// DataRef<T>::MetadataResults
template <typename T>
constexpr uint16_t DataRef<T>::MetadataResults::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t DataRef<T>::MetadataResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind DataRef<T>::MetadataResults::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* DataRef<T>::MetadataResults::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope DataRef<T>::MetadataResults::_capnpPrivate::brandScopes[] = {
  { 0xc85b8a7758032008, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding DataRef<T>::MetadataResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Dependency DataRef<T>::MetadataResults::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::fsc::DataRef<T>::Metadata::_capnpPrivate::brand() },
};
template <typename T>
const ::capnp::_::RawBrandedSchema DataRef<T>::MetadataResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_e665b0c0f7806137, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

template <typename T>
inline  ::uint64_t DataRef<T>::RawBytesParams::Reader::getStart() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename T>
inline  ::uint64_t DataRef<T>::RawBytesParams::Builder::getStart() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename T>
inline void DataRef<T>::RawBytesParams::Builder::setStart( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

template <typename T>
inline  ::uint64_t DataRef<T>::RawBytesParams::Reader::getEnd() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

template <typename T>
inline  ::uint64_t DataRef<T>::RawBytesParams::Builder::getEnd() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
template <typename T>
inline void DataRef<T>::RawBytesParams::Builder::setEnd( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

// DataRef<T>::RawBytesParams
template <typename T>
constexpr uint16_t DataRef<T>::RawBytesParams::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t DataRef<T>::RawBytesParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind DataRef<T>::RawBytesParams::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* DataRef<T>::RawBytesParams::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope DataRef<T>::RawBytesParams::_capnpPrivate::brandScopes[] = {
  { 0xc85b8a7758032008, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding DataRef<T>::RawBytesParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema DataRef<T>::RawBytesParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_c6d800d2ed4fcb33, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename T>
inline bool DataRef<T>::RawBytesResults::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool DataRef<T>::RawBytesResults::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline  ::capnp::Data::Reader DataRef<T>::RawBytesResults::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::capnp::Data::Builder DataRef<T>::RawBytesResults::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline void DataRef<T>::RawBytesResults::Builder::setData( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename T>
inline  ::capnp::Data::Builder DataRef<T>::RawBytesResults::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename T>
inline void DataRef<T>::RawBytesResults::Builder::adoptData(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan< ::capnp::Data> DataRef<T>::RawBytesResults::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// DataRef<T>::RawBytesResults
template <typename T>
constexpr uint16_t DataRef<T>::RawBytesResults::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t DataRef<T>::RawBytesResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind DataRef<T>::RawBytesResults::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* DataRef<T>::RawBytesResults::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope DataRef<T>::RawBytesResults::_capnpPrivate::brandScopes[] = {
  { 0xc85b8a7758032008, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding DataRef<T>::RawBytesResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema DataRef<T>::RawBytesResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_e3198e7e815c3f1d, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// DataRef<T>::CapTableParams
template <typename T>
constexpr uint16_t DataRef<T>::CapTableParams::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t DataRef<T>::CapTableParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind DataRef<T>::CapTableParams::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* DataRef<T>::CapTableParams::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope DataRef<T>::CapTableParams::_capnpPrivate::brandScopes[] = {
  { 0xc85b8a7758032008, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding DataRef<T>::CapTableParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema DataRef<T>::CapTableParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_ee498f3025b6138b, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename T>
inline bool DataRef<T>::CapTableResults::Reader::hasTable() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool DataRef<T>::CapTableResults::Builder::hasTable() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename T>
inline  ::capnp::List< ::capnp::Capability,  ::capnp::Kind::INTERFACE>::Reader DataRef<T>::CapTableResults::Reader::getTable() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Capability,  ::capnp::Kind::INTERFACE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::capnp::List< ::capnp::Capability,  ::capnp::Kind::INTERFACE>::Builder DataRef<T>::CapTableResults::Builder::getTable() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Capability,  ::capnp::Kind::INTERFACE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline void DataRef<T>::CapTableResults::Builder::setTable( ::capnp::List< ::capnp::Capability,  ::capnp::Kind::INTERFACE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Capability,  ::capnp::Kind::INTERFACE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename T>
inline  ::capnp::List< ::capnp::Capability,  ::capnp::Kind::INTERFACE>::Builder DataRef<T>::CapTableResults::Builder::initTable(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Capability,  ::capnp::Kind::INTERFACE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename T>
inline void DataRef<T>::CapTableResults::Builder::adoptTable(
    ::capnp::Orphan< ::capnp::List< ::capnp::Capability,  ::capnp::Kind::INTERFACE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Capability,  ::capnp::Kind::INTERFACE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan< ::capnp::List< ::capnp::Capability,  ::capnp::Kind::INTERFACE>> DataRef<T>::CapTableResults::Builder::disownTable() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Capability,  ::capnp::Kind::INTERFACE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

// DataRef<T>::CapTableResults
template <typename T>
constexpr uint16_t DataRef<T>::CapTableResults::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t DataRef<T>::CapTableResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind DataRef<T>::CapTableResults::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* DataRef<T>::CapTableResults::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope DataRef<T>::CapTableResults::_capnpPrivate::brandScopes[] = {
  { 0xc85b8a7758032008, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding DataRef<T>::CapTableResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema DataRef<T>::CapTableResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_e3343bd2ddce735d, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename T>
inline  ::uint64_t DataRef<T>::TransmitParams::Reader::getStart() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename T>
inline  ::uint64_t DataRef<T>::TransmitParams::Builder::getStart() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename T>
inline void DataRef<T>::TransmitParams::Builder::setStart( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

template <typename T>
inline  ::uint64_t DataRef<T>::TransmitParams::Reader::getEnd() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

template <typename T>
inline  ::uint64_t DataRef<T>::TransmitParams::Builder::getEnd() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
template <typename T>
inline void DataRef<T>::TransmitParams::Builder::setEnd( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

template <typename T>
inline bool DataRef<T>::TransmitParams::Reader::hasReceiver() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool DataRef<T>::TransmitParams::Builder::hasReceiver() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename T>
inline typename  ::fsc::DataRef<T>::Receiver::Client DataRef<T>::TransmitParams::Reader::getReceiver() const {
  return ::capnp::_::PointerHelpers<typename  ::fsc::DataRef<T>::Receiver>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline typename  ::fsc::DataRef<T>::Receiver::Client DataRef<T>::TransmitParams::Builder::getReceiver() {
  return ::capnp::_::PointerHelpers<typename  ::fsc::DataRef<T>::Receiver>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline typename  ::fsc::DataRef<T>::Receiver::Client DataRef<T>::TransmitParams::Pipeline::getReceiver() {
  return typename  ::fsc::DataRef<T>::Receiver::Client(_typeless.getPointerField(0).asCap());
}
template <typename T>
inline void DataRef<T>::TransmitParams::Builder::setReceiver(typename  ::fsc::DataRef<T>::Receiver::Client&& cap) {
  ::capnp::_::PointerHelpers<typename  ::fsc::DataRef<T>::Receiver>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename T>
inline void DataRef<T>::TransmitParams::Builder::setReceiver(typename  ::fsc::DataRef<T>::Receiver::Client& cap) {
  ::capnp::_::PointerHelpers<typename  ::fsc::DataRef<T>::Receiver>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
template <typename T>
inline void DataRef<T>::TransmitParams::Builder::adoptReceiver(
    ::capnp::Orphan<typename  ::fsc::DataRef<T>::Receiver>&& value) {
  ::capnp::_::PointerHelpers<typename  ::fsc::DataRef<T>::Receiver>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan<typename  ::fsc::DataRef<T>::Receiver> DataRef<T>::TransmitParams::Builder::disownReceiver() {
  return ::capnp::_::PointerHelpers<typename  ::fsc::DataRef<T>::Receiver>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

// DataRef<T>::TransmitParams
template <typename T>
constexpr uint16_t DataRef<T>::TransmitParams::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t DataRef<T>::TransmitParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind DataRef<T>::TransmitParams::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* DataRef<T>::TransmitParams::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope DataRef<T>::TransmitParams::_capnpPrivate::brandScopes[] = {
  { 0xc85b8a7758032008, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding DataRef<T>::TransmitParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Dependency DataRef<T>::TransmitParams::_capnpPrivate::brandDependencies[] = {
  { 16777218,  ::fsc::DataRef<T>::Receiver::_capnpPrivate::brand() },
};
template <typename T>
const ::capnp::_::RawBrandedSchema DataRef<T>::TransmitParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_ac2540aee80249f2, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

// DataRef<T>::TransmitResults
template <typename T>
constexpr uint16_t DataRef<T>::TransmitResults::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t DataRef<T>::TransmitResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind DataRef<T>::TransmitResults::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* DataRef<T>::TransmitResults::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope DataRef<T>::TransmitResults::_capnpPrivate::brandScopes[] = {
  { 0xc85b8a7758032008, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding DataRef<T>::TransmitResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema DataRef<T>::TransmitResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_a446c7e0ae9a6b7c, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename T>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::fsc::DataRef<T>::MetadataParams, typename  ::fsc::DataRef<T>::MetadataResults>)
DataRef<T>::Client::metadataRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::fsc::DataRef<T>::MetadataParams, typename  ::fsc::DataRef<T>::MetadataResults>(
      0xc85b8a7758032008ull, 0, sizeHint);
}
template <typename T>
::kj::Promise<void> DataRef<T>::Server::metadata(MetadataContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "data.capnp:DataRef", "metadata",
      0xc85b8a7758032008ull, 0);
}
template <typename T>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::fsc::DataRef<T>::RawBytesParams, typename  ::fsc::DataRef<T>::RawBytesResults>)
DataRef<T>::Client::rawBytesRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::fsc::DataRef<T>::RawBytesParams, typename  ::fsc::DataRef<T>::RawBytesResults>(
      0xc85b8a7758032008ull, 1, sizeHint);
}
template <typename T>
::kj::Promise<void> DataRef<T>::Server::rawBytes(RawBytesContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "data.capnp:DataRef", "rawBytes",
      0xc85b8a7758032008ull, 1);
}
template <typename T>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::fsc::DataRef<T>::CapTableParams, typename  ::fsc::DataRef<T>::CapTableResults>)
DataRef<T>::Client::capTableRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::fsc::DataRef<T>::CapTableParams, typename  ::fsc::DataRef<T>::CapTableResults>(
      0xc85b8a7758032008ull, 2, sizeHint);
}
template <typename T>
::kj::Promise<void> DataRef<T>::Server::capTable(CapTableContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "data.capnp:DataRef", "capTable",
      0xc85b8a7758032008ull, 2);
}
template <typename T>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::fsc::DataRef<T>::TransmitParams, typename  ::fsc::DataRef<T>::TransmitResults>)
DataRef<T>::Client::transmitRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::fsc::DataRef<T>::TransmitParams, typename  ::fsc::DataRef<T>::TransmitResults>(
      0xc85b8a7758032008ull, 3, sizeHint);
}
template <typename T>
::kj::Promise<void> DataRef<T>::Server::transmit(TransmitContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "data.capnp:DataRef", "transmit",
      0xc85b8a7758032008ull, 3);
}
template <typename T>
::capnp::Capability::Server::DispatchCallResult DataRef<T>::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0xc85b8a7758032008ull:
      return dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("data.capnp:DataRef", interfaceId);
  }
}
template <typename T>
::capnp::Capability::Server::DispatchCallResult DataRef<T>::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return {
        metadata(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::fsc::DataRef<T>::MetadataParams, typename  ::fsc::DataRef<T>::MetadataResults>(context)),
        false
      };
    case 1:
      return {
        rawBytes(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::fsc::DataRef<T>::RawBytesParams, typename  ::fsc::DataRef<T>::RawBytesResults>(context)),
        false
      };
    case 2:
      return {
        capTable(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::fsc::DataRef<T>::CapTableParams, typename  ::fsc::DataRef<T>::CapTableResults>(context)),
        false
      };
    case 3:
      return {
        transmit(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::fsc::DataRef<T>::TransmitParams, typename  ::fsc::DataRef<T>::TransmitResults>(context)),
        false
      };
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "data.capnp:DataRef",
          0xc85b8a7758032008ull, methodId);
  }
}
#endif  // !CAPNP_LITE

// DataRef<T>
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind DataRef<T>::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* DataRef<T>::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope DataRef<T>::_capnpPrivate::brandScopes[] = {
  { 0xc85b8a7758032008, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding DataRef<T>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Dependency DataRef<T>::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::fsc::DataRef<T>::MetadataParams::_capnpPrivate::brand() },
  { 33554433,  ::fsc::DataRef<T>::RawBytesParams::_capnpPrivate::brand() },
  { 33554434,  ::fsc::DataRef<T>::CapTableParams::_capnpPrivate::brand() },
  { 33554435,  ::fsc::DataRef<T>::TransmitParams::_capnpPrivate::brand() },
  { 50331648,  ::fsc::DataRef<T>::MetadataResults::_capnpPrivate::brand() },
  { 50331649,  ::fsc::DataRef<T>::RawBytesResults::_capnpPrivate::brand() },
  { 50331650,  ::fsc::DataRef<T>::CapTableResults::_capnpPrivate::brand() },
  { 50331651,  ::fsc::DataRef<T>::TransmitResults::_capnpPrivate::brand() },
};
template <typename T>
const ::capnp::_::RawBrandedSchema DataRef<T>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_c85b8a7758032008, brandScopes, brandDependencies,
  1, 8, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline DataService::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline DataService::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline DataService::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline DataService::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline DataService::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::fsc::DataService::Client& DataService::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::fsc::DataService::Client& DataService::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

template <typename T>
::capnp::Request< ::fsc::DataService::StoreParams<T>,  ::fsc::DataService::StoreResults<T>>
DataService::Client::storeRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall< ::fsc::DataService::StoreParams<T>,  ::fsc::DataService::StoreResults<T>>(
      0xc6d48902ddb7e122ull, 0, sizeHint);
}
template <typename T>
::capnp::Request< ::fsc::DataService::CloneParams<T>,  ::fsc::DataService::CloneResults<T>>
DataService::Client::cloneRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall< ::fsc::DataService::CloneParams<T>,  ::fsc::DataService::CloneResults<T>>(
      0xc6d48902ddb7e122ull, 1, sizeHint);
}
template <typename T>
::capnp::Request< ::fsc::DataService::CacheParams<T>,  ::fsc::DataService::CacheResults<T>>
DataService::Client::cacheRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall< ::fsc::DataService::CacheParams<T>,  ::fsc::DataService::CacheResults<T>>(
      0xc6d48902ddb7e122ull, 2, sizeHint);
}
#endif  // !CAPNP_LITE
template <typename T>
inline bool DataService::StoreParams<T>::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool DataService::StoreParams<T>::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline  ::capnp::Data::Reader DataService::StoreParams<T>::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::capnp::Data::Builder DataService::StoreParams<T>::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline void DataService::StoreParams<T>::Builder::setId( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename T>
inline  ::capnp::Data::Builder DataService::StoreParams<T>::Builder::initId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename T>
inline void DataService::StoreParams<T>::Builder::adoptId(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan< ::capnp::Data> DataService::StoreParams<T>::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename T>
inline bool DataService::StoreParams<T>::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool DataService::StoreParams<T>::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline  ::capnp::ReaderFor<T> DataService::StoreParams<T>::Reader::getData() const {
  return ::capnp::_::PointerHelpers<T>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::capnp::BuilderFor<T> DataService::StoreParams<T>::Builder::getData() {
  return ::capnp::_::PointerHelpers<T>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename T>
inline  ::capnp::PipelineFor<T> DataService::StoreParams<T>::Pipeline::getData() {
  return  ::capnp::PipelineFor<T>(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename T>
inline void DataService::StoreParams<T>::Builder::setData( ::capnp::ReaderFor<T> value) {
  ::capnp::_::PointerHelpers<T>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename T>
inline  ::capnp::BuilderFor<T> DataService::StoreParams<T>::Builder::initData() {
  return ::capnp::_::PointerHelpers<T>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::capnp::BuilderFor<T> DataService::StoreParams<T>::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers<T>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename T>
inline void DataService::StoreParams<T>::Builder::adoptData(
    ::capnp::Orphan<T>&& value) {
  ::capnp::_::PointerHelpers<T>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan<T> DataService::StoreParams<T>::Builder::disownData() {
  return ::capnp::_::PointerHelpers<T>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

// DataService::StoreParams<T>
template <typename T>
constexpr uint16_t DataService::StoreParams<T>::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t DataService::StoreParams<T>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind DataService::StoreParams<T>::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* DataService::StoreParams<T>::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope DataService::StoreParams<T>::_capnpPrivate::brandScopes[] = {
  { 0x94f450018e226986, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding DataService::StoreParams<T>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema DataService::StoreParams<T>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_94f450018e226986, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename T>
inline bool DataService::StoreResults<T>::Reader::hasRef() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool DataService::StoreResults<T>::Builder::hasRef() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename T>
inline typename  ::fsc::DataRef<T>::Client DataService::StoreResults<T>::Reader::getRef() const {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline typename  ::fsc::DataRef<T>::Client DataService::StoreResults<T>::Builder::getRef() {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline typename  ::fsc::DataRef<T>::Client DataService::StoreResults<T>::Pipeline::getRef() {
  return typename  ::fsc::DataRef<T>::Client(_typeless.getPointerField(0).asCap());
}
template <typename T>
inline void DataService::StoreResults<T>::Builder::setRef(typename  ::fsc::DataRef<T>::Client&& cap) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename T>
inline void DataService::StoreResults<T>::Builder::setRef(typename  ::fsc::DataRef<T>::Client& cap) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
template <typename T>
inline void DataService::StoreResults<T>::Builder::adoptRef(
    ::capnp::Orphan< ::fsc::DataRef<T>>&& value) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan< ::fsc::DataRef<T>> DataService::StoreResults<T>::Builder::disownRef() {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

// DataService::StoreResults<T>
template <typename T>
constexpr uint16_t DataService::StoreResults<T>::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t DataService::StoreResults<T>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind DataService::StoreResults<T>::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* DataService::StoreResults<T>::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope DataService::StoreResults<T>::_capnpPrivate::brandScopes[] = {
  { 0x92d2138cd3122bc3, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding DataService::StoreResults<T>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Dependency DataService::StoreResults<T>::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::fsc::DataRef<T>::_capnpPrivate::brand() },
};
template <typename T>
const ::capnp::_::RawBrandedSchema DataService::StoreResults<T>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_92d2138cd3122bc3, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

template <typename T>
inline bool DataService::CloneParams<T>::Reader::hasSource() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool DataService::CloneParams<T>::Builder::hasSource() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename T>
inline typename  ::fsc::DataRef<T>::Client DataService::CloneParams<T>::Reader::getSource() const {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline typename  ::fsc::DataRef<T>::Client DataService::CloneParams<T>::Builder::getSource() {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline typename  ::fsc::DataRef<T>::Client DataService::CloneParams<T>::Pipeline::getSource() {
  return typename  ::fsc::DataRef<T>::Client(_typeless.getPointerField(0).asCap());
}
template <typename T>
inline void DataService::CloneParams<T>::Builder::setSource(typename  ::fsc::DataRef<T>::Client&& cap) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename T>
inline void DataService::CloneParams<T>::Builder::setSource(typename  ::fsc::DataRef<T>::Client& cap) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
template <typename T>
inline void DataService::CloneParams<T>::Builder::adoptSource(
    ::capnp::Orphan< ::fsc::DataRef<T>>&& value) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan< ::fsc::DataRef<T>> DataService::CloneParams<T>::Builder::disownSource() {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

// DataService::CloneParams<T>
template <typename T>
constexpr uint16_t DataService::CloneParams<T>::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t DataService::CloneParams<T>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind DataService::CloneParams<T>::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* DataService::CloneParams<T>::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope DataService::CloneParams<T>::_capnpPrivate::brandScopes[] = {
  { 0x8624f871b2a83b18, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding DataService::CloneParams<T>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Dependency DataService::CloneParams<T>::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::fsc::DataRef<T>::_capnpPrivate::brand() },
};
template <typename T>
const ::capnp::_::RawBrandedSchema DataService::CloneParams<T>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_8624f871b2a83b18, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

template <typename T>
inline bool DataService::CloneResults<T>::Reader::hasRef() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool DataService::CloneResults<T>::Builder::hasRef() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename T>
inline typename  ::fsc::DataRef<T>::Client DataService::CloneResults<T>::Reader::getRef() const {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline typename  ::fsc::DataRef<T>::Client DataService::CloneResults<T>::Builder::getRef() {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline typename  ::fsc::DataRef<T>::Client DataService::CloneResults<T>::Pipeline::getRef() {
  return typename  ::fsc::DataRef<T>::Client(_typeless.getPointerField(0).asCap());
}
template <typename T>
inline void DataService::CloneResults<T>::Builder::setRef(typename  ::fsc::DataRef<T>::Client&& cap) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename T>
inline void DataService::CloneResults<T>::Builder::setRef(typename  ::fsc::DataRef<T>::Client& cap) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
template <typename T>
inline void DataService::CloneResults<T>::Builder::adoptRef(
    ::capnp::Orphan< ::fsc::DataRef<T>>&& value) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan< ::fsc::DataRef<T>> DataService::CloneResults<T>::Builder::disownRef() {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

// DataService::CloneResults<T>
template <typename T>
constexpr uint16_t DataService::CloneResults<T>::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t DataService::CloneResults<T>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind DataService::CloneResults<T>::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* DataService::CloneResults<T>::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope DataService::CloneResults<T>::_capnpPrivate::brandScopes[] = {
  { 0xbf78c5ee2bb7dba3, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding DataService::CloneResults<T>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Dependency DataService::CloneResults<T>::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::fsc::DataRef<T>::_capnpPrivate::brand() },
};
template <typename T>
const ::capnp::_::RawBrandedSchema DataService::CloneResults<T>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_bf78c5ee2bb7dba3, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

template <typename T>
inline bool DataService::CacheParams<T>::Reader::hasSource() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool DataService::CacheParams<T>::Builder::hasSource() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename T>
inline typename  ::fsc::DataRef<T>::Client DataService::CacheParams<T>::Reader::getSource() const {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline typename  ::fsc::DataRef<T>::Client DataService::CacheParams<T>::Builder::getSource() {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline typename  ::fsc::DataRef<T>::Client DataService::CacheParams<T>::Pipeline::getSource() {
  return typename  ::fsc::DataRef<T>::Client(_typeless.getPointerField(0).asCap());
}
template <typename T>
inline void DataService::CacheParams<T>::Builder::setSource(typename  ::fsc::DataRef<T>::Client&& cap) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename T>
inline void DataService::CacheParams<T>::Builder::setSource(typename  ::fsc::DataRef<T>::Client& cap) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
template <typename T>
inline void DataService::CacheParams<T>::Builder::adoptSource(
    ::capnp::Orphan< ::fsc::DataRef<T>>&& value) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan< ::fsc::DataRef<T>> DataService::CacheParams<T>::Builder::disownSource() {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

// DataService::CacheParams<T>
template <typename T>
constexpr uint16_t DataService::CacheParams<T>::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t DataService::CacheParams<T>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind DataService::CacheParams<T>::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* DataService::CacheParams<T>::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope DataService::CacheParams<T>::_capnpPrivate::brandScopes[] = {
  { 0xeda4f7157f306e3e, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding DataService::CacheParams<T>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Dependency DataService::CacheParams<T>::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::fsc::DataRef<T>::_capnpPrivate::brand() },
};
template <typename T>
const ::capnp::_::RawBrandedSchema DataService::CacheParams<T>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_eda4f7157f306e3e, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

template <typename T>
inline bool DataService::CacheResults<T>::Reader::hasRef() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool DataService::CacheResults<T>::Builder::hasRef() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename T>
inline typename  ::fsc::DataRef<T>::Client DataService::CacheResults<T>::Reader::getRef() const {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline typename  ::fsc::DataRef<T>::Client DataService::CacheResults<T>::Builder::getRef() {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline typename  ::fsc::DataRef<T>::Client DataService::CacheResults<T>::Pipeline::getRef() {
  return typename  ::fsc::DataRef<T>::Client(_typeless.getPointerField(0).asCap());
}
template <typename T>
inline void DataService::CacheResults<T>::Builder::setRef(typename  ::fsc::DataRef<T>::Client&& cap) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename T>
inline void DataService::CacheResults<T>::Builder::setRef(typename  ::fsc::DataRef<T>::Client& cap) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
template <typename T>
inline void DataService::CacheResults<T>::Builder::adoptRef(
    ::capnp::Orphan< ::fsc::DataRef<T>>&& value) {
  ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan< ::fsc::DataRef<T>> DataService::CacheResults<T>::Builder::disownRef() {
  return ::capnp::_::PointerHelpers< ::fsc::DataRef<T>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

// DataService::CacheResults<T>
template <typename T>
constexpr uint16_t DataService::CacheResults<T>::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t DataService::CacheResults<T>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind DataService::CacheResults<T>::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* DataService::CacheResults<T>::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope DataService::CacheResults<T>::_capnpPrivate::brandScopes[] = {
  { 0xce6dcc82e239b77b, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding DataService::CacheResults<T>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Dependency DataService::CacheResults<T>::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::fsc::DataRef<T>::_capnpPrivate::brand() },
};
template <typename T>
const ::capnp::_::RawBrandedSchema DataService::CacheResults<T>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_ce6dcc82e239b77b, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

inline bool Archive::Reader::hasRoot() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Archive::Builder::hasRoot() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::fsc::Archive::Entry::Reader Archive::Reader::getRoot() const {
  return ::capnp::_::PointerHelpers< ::fsc::Archive::Entry>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::fsc::Archive::Entry::Builder Archive::Builder::getRoot() {
  return ::capnp::_::PointerHelpers< ::fsc::Archive::Entry>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fsc::Archive::Entry::Pipeline Archive::Pipeline::getRoot() {
  return  ::fsc::Archive::Entry::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Archive::Builder::setRoot( ::fsc::Archive::Entry::Reader value) {
  ::capnp::_::PointerHelpers< ::fsc::Archive::Entry>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::fsc::Archive::Entry::Builder Archive::Builder::initRoot() {
  return ::capnp::_::PointerHelpers< ::fsc::Archive::Entry>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Archive::Builder::adoptRoot(
    ::capnp::Orphan< ::fsc::Archive::Entry>&& value) {
  ::capnp::_::PointerHelpers< ::fsc::Archive::Entry>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fsc::Archive::Entry> Archive::Builder::disownRoot() {
  return ::capnp::_::PointerHelpers< ::fsc::Archive::Entry>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Archive::Reader::hasExtra() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Archive::Builder::hasExtra() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::fsc::Archive::Entry,  ::capnp::Kind::STRUCT>::Reader Archive::Reader::getExtra() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Archive::Entry,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::fsc::Archive::Entry,  ::capnp::Kind::STRUCT>::Builder Archive::Builder::getExtra() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Archive::Entry,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Archive::Builder::setExtra( ::capnp::List< ::fsc::Archive::Entry,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Archive::Entry,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::fsc::Archive::Entry,  ::capnp::Kind::STRUCT>::Builder Archive::Builder::initExtra(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Archive::Entry,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Archive::Builder::adoptExtra(
    ::capnp::Orphan< ::capnp::List< ::fsc::Archive::Entry,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Archive::Entry,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::fsc::Archive::Entry,  ::capnp::Kind::STRUCT>> Archive::Builder::disownExtra() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Archive::Entry,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline typename Archive::CapabilityInfo::DataRefInfo::Reader Archive::CapabilityInfo::Reader::getDataRefInfo() const {
  return typename Archive::CapabilityInfo::DataRefInfo::Reader(_reader);
}
inline typename Archive::CapabilityInfo::DataRefInfo::Builder Archive::CapabilityInfo::Builder::getDataRefInfo() {
  return typename Archive::CapabilityInfo::DataRefInfo::Builder(_builder);
}
#if !CAPNP_LITE
inline typename Archive::CapabilityInfo::DataRefInfo::Pipeline Archive::CapabilityInfo::Pipeline::getDataRefInfo() {
  return typename Archive::CapabilityInfo::DataRefInfo::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename Archive::CapabilityInfo::DataRefInfo::Builder Archive::CapabilityInfo::Builder::initDataRefInfo() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename Archive::CapabilityInfo::DataRefInfo::Builder(_builder);
}
inline  ::fsc::Archive::CapabilityInfo::DataRefInfo::Which Archive::CapabilityInfo::DataRefInfo::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::fsc::Archive::CapabilityInfo::DataRefInfo::Which Archive::CapabilityInfo::DataRefInfo::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Archive::CapabilityInfo::DataRefInfo::Reader::isNoDataRef() const {
  return which() == Archive::CapabilityInfo::DataRefInfo::NO_DATA_REF;
}
inline bool Archive::CapabilityInfo::DataRefInfo::Builder::isNoDataRef() {
  return which() == Archive::CapabilityInfo::DataRefInfo::NO_DATA_REF;
}
inline  ::capnp::Void Archive::CapabilityInfo::DataRefInfo::Reader::getNoDataRef() const {
  KJ_IREQUIRE((which() == Archive::CapabilityInfo::DataRefInfo::NO_DATA_REF),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Archive::CapabilityInfo::DataRefInfo::Builder::getNoDataRef() {
  KJ_IREQUIRE((which() == Archive::CapabilityInfo::DataRefInfo::NO_DATA_REF),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Archive::CapabilityInfo::DataRefInfo::Builder::setNoDataRef( ::capnp::Void value) {
  _builder.setDataField<Archive::CapabilityInfo::DataRefInfo::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Archive::CapabilityInfo::DataRefInfo::NO_DATA_REF);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Archive::CapabilityInfo::DataRefInfo::Reader::isRefID() const {
  return which() == Archive::CapabilityInfo::DataRefInfo::REF_I_D;
}
inline bool Archive::CapabilityInfo::DataRefInfo::Builder::isRefID() {
  return which() == Archive::CapabilityInfo::DataRefInfo::REF_I_D;
}
inline bool Archive::CapabilityInfo::DataRefInfo::Reader::hasRefID() const {
  if (which() != Archive::CapabilityInfo::DataRefInfo::REF_I_D) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Archive::CapabilityInfo::DataRefInfo::Builder::hasRefID() {
  if (which() != Archive::CapabilityInfo::DataRefInfo::REF_I_D) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader Archive::CapabilityInfo::DataRefInfo::Reader::getRefID() const {
  KJ_IREQUIRE((which() == Archive::CapabilityInfo::DataRefInfo::REF_I_D),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder Archive::CapabilityInfo::DataRefInfo::Builder::getRefID() {
  KJ_IREQUIRE((which() == Archive::CapabilityInfo::DataRefInfo::REF_I_D),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Archive::CapabilityInfo::DataRefInfo::Builder::setRefID( ::capnp::Data::Reader value) {
  _builder.setDataField<Archive::CapabilityInfo::DataRefInfo::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Archive::CapabilityInfo::DataRefInfo::REF_I_D);
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder Archive::CapabilityInfo::DataRefInfo::Builder::initRefID(unsigned int size) {
  _builder.setDataField<Archive::CapabilityInfo::DataRefInfo::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Archive::CapabilityInfo::DataRefInfo::REF_I_D);
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Archive::CapabilityInfo::DataRefInfo::Builder::adoptRefID(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  _builder.setDataField<Archive::CapabilityInfo::DataRefInfo::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Archive::CapabilityInfo::DataRefInfo::REF_I_D);
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> Archive::CapabilityInfo::DataRefInfo::Builder::disownRefID() {
  KJ_IREQUIRE((which() == Archive::CapabilityInfo::DataRefInfo::REF_I_D),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Archive::Entry::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Archive::Entry::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader Archive::Entry::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder Archive::Entry::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Archive::Entry::Builder::setId( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder Archive::Entry::Builder::initId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Archive::Entry::Builder::adoptId(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> Archive::Entry::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Archive::Entry::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Archive::Entry::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Reader Archive::Entry::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Builder Archive::Entry::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Archive::Entry::Builder::setData( ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void Archive::Entry::Builder::setData(::kj::ArrayPtr<const  ::capnp::Data::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Builder Archive::Entry::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Archive::Entry::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>> Archive::Entry::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Archive::Entry::Reader::hasCapabilities() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Archive::Entry::Builder::hasCapabilities() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::fsc::Archive::CapabilityInfo,  ::capnp::Kind::STRUCT>::Reader Archive::Entry::Reader::getCapabilities() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Archive::CapabilityInfo,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::fsc::Archive::CapabilityInfo,  ::capnp::Kind::STRUCT>::Builder Archive::Entry::Builder::getCapabilities() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Archive::CapabilityInfo,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Archive::Entry::Builder::setCapabilities( ::capnp::List< ::fsc::Archive::CapabilityInfo,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Archive::CapabilityInfo,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::fsc::Archive::CapabilityInfo,  ::capnp::Kind::STRUCT>::Builder Archive::Entry::Builder::initCapabilities(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Archive::CapabilityInfo,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Archive::Entry::Builder::adoptCapabilities(
    ::capnp::Orphan< ::capnp::List< ::fsc::Archive::CapabilityInfo,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Archive::CapabilityInfo,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::fsc::Archive::CapabilityInfo,  ::capnp::Kind::STRUCT>> Archive::Entry::Builder::disownCapabilities() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fsc::Archive::CapabilityInfo,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::uint64_t Archive::Entry::Reader::getTypeId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Archive::Entry::Builder::getTypeId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Archive::Entry::Builder::setTypeId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Float64Tensor::Reader::hasShape() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Float64Tensor::Builder::hasShape() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader Float64Tensor::Reader::getShape() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder Float64Tensor::Builder::getShape() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Float64Tensor::Builder::setShape( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Float64Tensor::Builder::setShape(::kj::ArrayPtr<const  ::uint64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder Float64Tensor::Builder::initShape(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Float64Tensor::Builder::adoptShape(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> Float64Tensor::Builder::disownShape() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Float64Tensor::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Float64Tensor::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader Float64Tensor::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder Float64Tensor::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Float64Tensor::Builder::setData( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void Float64Tensor::Builder::setData(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder Float64Tensor::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Float64Tensor::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> Float64Tensor::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Float32Tensor::Reader::hasShape() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Float32Tensor::Builder::hasShape() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader Float32Tensor::Reader::getShape() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder Float32Tensor::Builder::getShape() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Float32Tensor::Builder::setShape( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Float32Tensor::Builder::setShape(::kj::ArrayPtr<const  ::uint64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder Float32Tensor::Builder::initShape(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Float32Tensor::Builder::adoptShape(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> Float32Tensor::Builder::disownShape() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Float32Tensor::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Float32Tensor::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader Float32Tensor::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder Float32Tensor::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Float32Tensor::Builder::setData( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void Float32Tensor::Builder::setData(::kj::ArrayPtr<const float> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder Float32Tensor::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Float32Tensor::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> Float32Tensor::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Int64Tensor::Reader::hasShape() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Int64Tensor::Builder::hasShape() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader Int64Tensor::Reader::getShape() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder Int64Tensor::Builder::getShape() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Int64Tensor::Builder::setShape( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Int64Tensor::Builder::setShape(::kj::ArrayPtr<const  ::uint64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder Int64Tensor::Builder::initShape(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Int64Tensor::Builder::adoptShape(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> Int64Tensor::Builder::disownShape() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Int64Tensor::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Int64Tensor::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Reader Int64Tensor::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Builder Int64Tensor::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Int64Tensor::Builder::setData( ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void Int64Tensor::Builder::setData(::kj::ArrayPtr<const  ::int64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Builder Int64Tensor::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Int64Tensor::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>> Int64Tensor::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool UInt64Tensor::Reader::hasShape() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool UInt64Tensor::Builder::hasShape() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader UInt64Tensor::Reader::getShape() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder UInt64Tensor::Builder::getShape() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void UInt64Tensor::Builder::setShape( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void UInt64Tensor::Builder::setShape(::kj::ArrayPtr<const  ::uint64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder UInt64Tensor::Builder::initShape(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void UInt64Tensor::Builder::adoptShape(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> UInt64Tensor::Builder::disownShape() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool UInt64Tensor::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool UInt64Tensor::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader UInt64Tensor::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder UInt64Tensor::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void UInt64Tensor::Builder::setData( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void UInt64Tensor::Builder::setData(::kj::ArrayPtr<const  ::uint64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder UInt64Tensor::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void UInt64Tensor::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> UInt64Tensor::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Int32Tensor::Reader::hasShape() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Int32Tensor::Builder::hasShape() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader Int32Tensor::Reader::getShape() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder Int32Tensor::Builder::getShape() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Int32Tensor::Builder::setShape( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Int32Tensor::Builder::setShape(::kj::ArrayPtr<const  ::uint64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder Int32Tensor::Builder::initShape(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Int32Tensor::Builder::adoptShape(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> Int32Tensor::Builder::disownShape() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Int32Tensor::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Int32Tensor::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Reader Int32Tensor::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Builder Int32Tensor::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Int32Tensor::Builder::setData( ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void Int32Tensor::Builder::setData(::kj::ArrayPtr<const  ::int32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Builder Int32Tensor::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Int32Tensor::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>> Int32Tensor::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool UInt32Tensor::Reader::hasShape() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool UInt32Tensor::Builder::hasShape() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader UInt32Tensor::Reader::getShape() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder UInt32Tensor::Builder::getShape() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void UInt32Tensor::Builder::setShape( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void UInt32Tensor::Builder::setShape(::kj::ArrayPtr<const  ::uint64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder UInt32Tensor::Builder::initShape(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void UInt32Tensor::Builder::adoptShape(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> UInt32Tensor::Builder::disownShape() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool UInt32Tensor::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool UInt32Tensor::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader UInt32Tensor::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder UInt32Tensor::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void UInt32Tensor::Builder::setData( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void UInt32Tensor::Builder::setData(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder UInt32Tensor::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void UInt32Tensor::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> UInt32Tensor::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

template <typename ListType>
inline bool ShapedList<ListType>::Reader::hasShape() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename ListType>
inline bool ShapedList<ListType>::Builder::hasShape() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename ListType>
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader ShapedList<ListType>::Reader::getShape() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename ListType>
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder ShapedList<ListType>::Builder::getShape() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename ListType>
inline void ShapedList<ListType>::Builder::setShape( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename ListType>
inline void ShapedList<ListType>::Builder::setShape(::kj::ArrayPtr<const  ::uint64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename ListType>
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder ShapedList<ListType>::Builder::initShape(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename ListType>
inline void ShapedList<ListType>::Builder::adoptShape(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename ListType>
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> ShapedList<ListType>::Builder::disownShape() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename ListType>
inline bool ShapedList<ListType>::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename ListType>
inline bool ShapedList<ListType>::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename ListType>
inline  ::capnp::ReaderFor<ListType> ShapedList<ListType>::Reader::getData() const {
  return ::capnp::_::PointerHelpers<ListType>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename ListType>
inline  ::capnp::BuilderFor<ListType> ShapedList<ListType>::Builder::getData() {
  return ::capnp::_::PointerHelpers<ListType>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename ListType>
inline  ::capnp::PipelineFor<ListType> ShapedList<ListType>::Pipeline::getData() {
  return  ::capnp::PipelineFor<ListType>(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename ListType>
inline void ShapedList<ListType>::Builder::setData( ::capnp::ReaderFor<ListType> value) {
  ::capnp::_::PointerHelpers<ListType>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename ListType>
inline  ::capnp::BuilderFor<ListType> ShapedList<ListType>::Builder::initData() {
  return ::capnp::_::PointerHelpers<ListType>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename ListType>
inline  ::capnp::BuilderFor<ListType> ShapedList<ListType>::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers<ListType>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename ListType>
inline void ShapedList<ListType>::Builder::adoptData(
    ::capnp::Orphan<ListType>&& value) {
  ::capnp::_::PointerHelpers<ListType>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename ListType>
inline ::capnp::Orphan<ListType> ShapedList<ListType>::Builder::disownData() {
  return ::capnp::_::PointerHelpers<ListType>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

// ShapedList<ListType>
template <typename ListType>
constexpr uint16_t ShapedList<ListType>::_capnpPrivate::dataWordSize;
template <typename ListType>
constexpr uint16_t ShapedList<ListType>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename ListType>
constexpr ::capnp::Kind ShapedList<ListType>::_capnpPrivate::kind;
template <typename ListType>
constexpr ::capnp::_::RawSchema const* ShapedList<ListType>::_capnpPrivate::schema;
template <typename ListType>
const ::capnp::_::RawBrandedSchema::Scope ShapedList<ListType>::_capnpPrivate::brandScopes[] = {
  { 0xe58f80c73717e663, brandBindings + 0, 1, false},
};
template <typename ListType>
const ::capnp::_::RawBrandedSchema::Binding ShapedList<ListType>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<ListType>(),
};
template <typename ListType>
const ::capnp::_::RawBrandedSchema ShapedList<ListType>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_e58f80c73717e663, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

}  // namespace

CAPNP_END_HEADER

